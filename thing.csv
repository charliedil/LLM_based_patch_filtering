,content,label,pred
0,"-import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.MalformedURLException;
 import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLStreamHandler;
+import java.net.URLStreamHandlerFactory;
+import java.util.HashMap;
+import java.util.Map;
",0,0
1,"-    private boolean useContextClassLoader = true;
-
",1,0
2,"+        digester.setClassLoader( classLoader );
",1,0
3,"+
+        XmlRulesModule xmlRulesModule = new XmlRulesModule( new NameSpaceURIRulesBinder( rulesBinder() ),
+                                                            getSystemIds(), rootPath );
+        Digester digester = newLoader( xmlRulesModule )
+                .register( DIGESTER_PUBLIC_ID, xmlRulesDtdUrl.toString() )
+                .setXIncludeAware( true )
+                .setValidating( true )
+                .newDigester();
+
+        try
+        {
+            digester.parse( inputSource );
+        }
+        catch ( Exception e )
+        {
+            addError( ""Impossible to load XML defined in the InputSource '%s': %s"", inputSource.getSystemId(),
+                      e.getMessage() );
+        }
",1,0
4,"+package org.apache.commons.digester3.binder;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Entity.
+ */
+public class Entity
+{
+
+    private String author = null;
+
+    /**
+     * @return Returns the author.
+     */
+    public String getAuthor()
+    {
+        return author;
+    }
+
+    /**
+     * @param author The author to set.
+     */
+    public void setAuthor( String author )
+    {
+        this.author = author;
+    }
+
+}
",0,0
5,"+        this.clazz = clazz;
",1,0
6,"+    @Test
+    public void testGetResource()
+    {
+        ClassLoader clToAdapt = new ClassLoader()
+        {
+
+            @Override
+            public URL getResource( String name )
+            {
+                if ( ""xxx"".equals( name ) )
+                {
+                    return super.getResource( ""org/apache/commons/digester3/binder/BinderClassLoaderTestCase.class"" );
+                }
+                return super.getResource( name );
+            }
+
+        };
+        ClassLoader binderCl = createBinderClassLoader( clToAdapt );
+        assertNotNull( binderCl.getResource( ""xxx"" ) );
+    }
+
",0,0
7,"-<container>
-  <header>
-    <authors>
-      <author>Author 1</author>
-    </authors>
-  </header>
-</container>
+<employee>
+  <name>Author 1</name>
+</employee> 
",0,0
8,"+        final URL url = Digester163TestCase.class.getResource( ""test.xml"" );
",0,0
9,"-import java.util.ArrayList;
 import java.util.HashSet;
-import java.util.List;
",1,0
10,"+ * [DIGESTER-126] Potential NullPointerException if debug is enabled in
+                  FactoryCreateRule#begin()
+
",0,0
11,"-     * 
+     *
",0,0
12,"-            if ( memoryRulesBinder.getIncludedFiles().add( xmlRulesResource.toString() ) )
+            Set<String> includedFiles = memoryRulesBinder.getIncludedFiles();
+            String xmlRulesResourceString = xmlRulesResource.toString();
+            if ( includedFiles.add( xmlRulesResourceString ) )
             {
-                install( new FromXmlRulesModule()
+                try
                 {
-
-                    @Override
-                    protected void loadRules()
+                    install( new FromXmlRulesModule()
                     {
-                        loadXMLRules( xmlRulesResource );
-                    }
 
-                } );
+                        @Override
+                        protected void loadRules()
+                        {
+                            loadXMLRules( xmlRulesResource );
+                        }
+
+                    } );
+                }
+                finally
+                {
+                    includedFiles.remove( xmlRulesResourceString );
+                }
",1,0
13,"- * 
+ *
",0,0
14,"-        return adaptedClassLoader.loadClass( name );
+        return getParent().loadClass( name );
",1,0
15,"+    public void testSingle()
+        throws IOException, SAXException
+    {
+        Digester dig = loader.newDigester();
+        URL url = Digester163TestCase.class.getResource( ""test.xml"" );
+        // lets parse - result does not matter here
+        Entity et = dig.parse( url );
+        assertEquals( ""Author 1"", et.getAuthor() );
+    }
+
+    @Test
",0,0
16,"- * 
+ *
",0,0
17,"+    <action dev=""simonetripodi"" type=""fix"" issue=""DIGESTER-167"" due-to=""Eugene Fedotov"">
+      Groundless ""Circular file inclusion detected"" exception when including rules XML file
+    </action>
",0,0
18,"+        final URL url = getClass().getResource( ""rules.xml"" );
",0,0
19,"+    <action dev=""simonetripodi"" type=""fix"" issue=""DIGESTER-154"">
+      The DigesterBinder is not able to load primitive classes by name
+    </action>
",0,0
20,"-     * 
+     *
",0,0
21,"-    private boolean useContextClassLoader;
+    private boolean useContextClassLoader = true;
",1,0
22,"-        rulesBinder.addError( messagePattern, arguments );
+        rulesBinders.get().addError( messagePattern, arguments );
",0,0
23,"+package org.apache.commons.digester3.binder;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import static org.apache.commons.digester3.binder.BinderClassLoader.createBinderClassLoader;
+import static org.junit.Assert.assertSame;
+
+import org.junit.Test;
+
+/**
+ * DIGESTER-155
+ */
+public final class BinderClassLoaderTestCase
+{
+
+    private ClassLoader classLoader = createBinderClassLoader( getClass().getClassLoader() );
+
+    @Test
+    public void loadBoolean()
+        throws Exception
+    {
+        typeFound( ""boolean"", boolean.class );
+    }
+
+    @Test
+    public void loadByte()
+        throws Exception
+    {
+        typeFound( ""byte"", byte.class );
+    }
+
+    @Test
+    public void loadShort()
+        throws Exception
+    {
+        typeFound( ""short"", short.class );
+    }
+
+    @Test
+    public void loadInt()
+        throws Exception
+    {
+        typeFound( ""int"", int.class );
+    }
+
+    @Test
+    public void loadChar()
+        throws Exception
+    {
+        typeFound( ""char"", char.class );
+    }
+
+    @Test
+    public void loadLong()
+        throws Exception
+    {
+        typeFound( ""long"", long.class );
+    }
+
+    @Test
+    public void loadFloat()
+        throws Exception
+    {
+        typeFound( ""float"", float.class );
+    }
+
+    @Test
+    public void loadDouble()
+        throws Exception
+    {
+        typeFound( ""double"", double.class );
+    }
+
+    private void typeFound( String name, Class<?> expected )
+        throws Exception
+    {
+        Class<?> actual = classLoader.loadClass( name );
+        assertSame( expected, actual );
+    }
+
+}
",0,1
24,"-            inputSource.clear();
+            systemIds.clear();
",1,0
25,"+    <action dev=""simonetripodi"" type=""fix"" issue=""DIGESTER-163"" due-to=""Torsten Krah"">
+      ConcurrentModificationException creating a new Digester via loaderInstance.newDigester()
+    </action>
",0,0
26,"+package org.apache.commons.digester3.binder;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+final class BinderClassLoader
+    extends ClassLoader
+{
+
+    private static final Map<String, Class<?>> PRIMITIVE_TYPES;
+    static
+    {
+        HashMap<String, Class<?>> primitiveTypes = new HashMap<String, Class<?>>();
+        primitiveTypes.put( ""boolean"", boolean.class );
+        primitiveTypes.put( ""byte"", byte.class );
+        primitiveTypes.put( ""short"", short.class );
+        primitiveTypes.put( ""int"", int.class );
+        primitiveTypes.put( ""char"", char.class );
+        primitiveTypes.put( ""long"", long.class );
+        primitiveTypes.put( ""float"", float.class );
+        primitiveTypes.put( ""double"", double.class );
+        PRIMITIVE_TYPES = Collections.unmodifiableMap( primitiveTypes );
+    }
+
+    private final ClassLoader adaptedClassLoader;
+
+    public BinderClassLoader( ClassLoader adaptedClassLoader )
+    {
+        this.adaptedClassLoader = adaptedClassLoader;
+    }
+
+    public ClassLoader getAdaptedClassLoader()
+    {
+        return adaptedClassLoader;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected synchronized Class<?> loadClass( String name, boolean resolve )
+        throws ClassNotFoundException
+    {
+        if ( PRIMITIVE_TYPES.containsKey( name ) )
+        {
+            return PRIMITIVE_TYPES.get( name );
+        }
+        return adaptedClassLoader.loadClass( name );
+    }
+
+}
",1,0
27,"+package org.apache.commons.digester3.binder;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.fail;
+import static org.apache.commons.digester3.binder.DigesterLoader.newLoader;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.commons.digester3.Digester;
+import org.apache.commons.digester3.xmlrules.FromXmlRulesModule;
+import org.junit.Before;
+import org.junit.Test;
+
+
+/**
+ * Test.
+ */
+public class Digester163TestCase
+{
+
+    public static final int MAX_THREADS = 4;
+
+    private DigesterLoader loader;
+
+    @Before
+    public void setUp()
+    {
+        loader = newLoader( new FromXmlRulesModule()
+        {
+
+            @Override
+            protected void loadRules()
+            {
+                loadXMLRules( getClass().getResourceAsStream( ""rules.xml"" ) );
+            }
+
+        } );
+    }
+
+    @Test
+    public void test()
+        throws InterruptedException
+    {
+        ThreadPoolExecutor executor = new ThreadPoolExecutor( MAX_THREADS, MAX_THREADS,
+                                                              Long.MAX_VALUE,
+                                                              TimeUnit.NANOSECONDS,
+                                                              new LinkedBlockingQueue<Runnable>() );
+        for ( int i = 0; i < MAX_THREADS * 2; i++ )
+        {
+            executor.submit( new Runnable()
+            {
+
+                public void run()
+                {
+                    Digester dig = loader.newDigester();
+                    InputStream in = null;
+                    try
+                    {
+                        in = this.getClass().getClassLoader().getResourceAsStream( ""test.xml"" );
+                        Entity et = dig.parse( in );
+                        assertEquals( ""Author 1"", et.getAuthor() );
+                    }
+                    catch ( Exception e )
+                    {
+                        fail( e.getMessage() );
+                    }
+                    finally
+                    {
+                        if ( in != null )
+                        {
+                            try
+                            {
+                                in.close();
+                            }
+                            catch ( IOException e )
+                            {
+                                // close quietly
+                            }
+                        }
+                    }
+                }
+            } );
+        }
+
+        while ( !executor.awaitTermination( 10, TimeUnit.MILLISECONDS ) )
+        {
+            if ( executor.getQueue().isEmpty() )
+            {
+                executor.shutdown();
+            }
+            if ( executor.isTerminated() )
+            {
+                break;
+            }
+        }
+    }
+
+}
",0,1
28,"- * 
+ *
",0,0
29,"- * 
+ *
",0,0
30,"-            return null;
+            throw new EmptyStackException();
",1,0
31,"-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
",1,0
32,"+  <profiles>
+    <profile>
+      <id>rc</id>
+      <build>
+        
+      </build>
+    </profile>
+  </profiles>
+
",0,0
33,"-                    ArrayList<String> stringList = getDigester().peek();
+                    List<String> stringList = getDigester().peek();
",0,0
34,"+    <action dev=""simonetripodi"" type=""fix"" issue=""DIGESTER-155"">
+      ClassLoader reference set to DigesterLoader not set in produced Digetser instances
+    </action>
",0,0
35,"-     * 
+     *
",0,0
36,"+     * The Java class of the object to be created.
+     */
+    protected Class<?> clazz = null;
+
+    /**
",1,0
37,"+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the ""License""); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an ""AS IS"" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<root>
+  <container>
+    <header>
+      <authors>
+        <author>Author 1</author>
+      </authors>
+    </header>
+  </container>
+</root>
",0,0
38,"+        this.clazz = clazz;
",1,0
39,"+        if ( classLoader == null )
+        {
+            throw new IllegalArgumentException( ""Parameter 'classLoader' cannot be null"" );
+        }
+
",1,0
40,"+import org.apache.xml.security.utils.resolver.ResourceResolverContext;
",1,0
41,"+            int offset = Character.toChars(ch, chs, pos);
+            pos += offset;
             if (ch == 0xDBFF) {
-                ch = 1;
+                // since 0xDBFF with next character 0xDC00 will form a surrogate pair, so insert a space character in between
+                offset = Character.toChars(Character.SPACE_SEPARATOR, chs, pos);
+                pos += offset;
             }
-            chs[i] = (char)ch;
-            UtfHelpper.writeCharToUtf8((char)ch, charByCharOs);
         }
-        String str = new String(chs);
+        char newResult[] = new char[pos];
+        System.arraycopy(chs, 0, newResult, 0, pos);
+        for (int i = 0; i < pos; ) {
+            int ch = Character.codePointAt(newResult, i);
+            i += Character.charCount(ch);
+            UtfHelpper.writeCodePointToUtf8(ch, charByCharOs);
+        }
+
+        String str = new String(newResult);
",0,0
42,"+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.xml.security.test.c14n.implementations;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.NodeList;
+
+import org.apache.xml.security.c14n.implementations.Canonicalizer11;
+import org.apache.xml.security.c14n.implementations.Canonicalizer11_OmitComments;
+
+/**
+ * This is a test for Santuario-191:
+ * 
+ * https://issues.apache.org/jira/browse/SANTUARIO-191
+ *
+ * An xml:Id attribute is appearing in a child element, contrary to the C14n11 spec.
+ */
+public class Santuario191Test extends TestCase {
+
+    private static final String INPUT_DATA =
+        ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>""
+      + ""<test xml:id=\""testid1\"">""
+      + ""<data>""
+      + ""    <user1>Alice</user1>""
+      + ""    <user2>Bob</user2>""
+      + ""</data>""
+      + ""</test>"";
+    private static final String EXPECTED_RESULT =
+        ""<data>""
+      + ""    <user1>Alice</user1>""
+      + ""    <user2>Bob</user2>""
+      + ""</data>"";
+
+    private DocumentBuilder db;
+    
+    static {
+        org.apache.xml.security.Init.init();
+    }
+    
+    public static Test suite() {
+        return new TestSuite(Santuario191Test.class);
+    }
+
+    public void testSantuario191() throws Exception {
+        //
+        // Parse the Data
+        //
+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
+        dbf.setNamespaceAware(true);
+        db = dbf.newDocumentBuilder();
+        Document doc = db.parse(new ByteArrayInputStream(INPUT_DATA.getBytes(""UTF8"")));
+        
+        //
+        // Canonicalize the data
+        //
+        NodeList dataNodes = doc.getElementsByTagName(""data"");
+        Canonicalizer11 c14ner = new Canonicalizer11_OmitComments();
+        byte[] result = c14ner.engineCanonicalizeSubTree(dataNodes.item(0));
+        
+        //
+        // Test against expected result
+        //
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        out.write(result);
+        assertTrue(EXPECTED_RESULT.equals(out.toString(""UTF8"")));
+    }
+    
+}
",0,1
43,"-package org.jcp.xml.dsig.internal.dom;
+package org.apache.jcp.xml.dsig.internal.dom;
",1,0
44,"+import org.w3c.dom.DOMException;
",1,0
45,"+<etsi:elem2 xmlns:etsi=""http://example.net""><dsig:stuff xmlns:dsig=""foo:bar""></dsig:stuff></etsi:elem2><
\ No newline at end of file
",0,0
46,"-package org.jcp.xml.dsig.internal.dom;
+package org.apache.jcp.xml.dsig.internal.dom;
",1,0
47,"+
+    @Override
+    public void writeAsEncodedUnicode(Writer writer) throws XMLStreamException {
+        try {
+            writer.write(""</"");
+            final String prefix = getName().getPrefix();
+            if (prefix != null && !prefix.isEmpty()) {
+                writer.write(getName().getPrefix());
+                writer.write(':');
+            }
+            writer.write(getName().getLocalPart());
+            writer.write('>');
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
",1,0
48,"-            (""DOM"", new org.jcp.xml.dsig.internal.dom.XMLDSigRI());
+            (""DOM"", new org.apache.jcp.xml.dsig.internal.dom.XMLDSigRI());
",0,0
49,"+import org.apache.xml.security.utils.resolver.ResourceResolverContext;
",1,0
50,"+    // @see https://issues.apache.org/jira/browse/SANTUARIO-433
+    @Test
+    public void testNullPrefix() throws Exception {
+        StringWriter securityStringWriter = new StringWriter();
+        OutboundSecurityContextImpl securityContext = new OutboundSecurityContextImpl();
+        OutputProcessorChainImpl outputProcessorChain = new OutputProcessorChainImpl(securityContext);
+        outputProcessorChain.addProcessor(new EventWriterProcessor(securityStringWriter));
+        XMLSecurityStreamWriter xmlSecurityStreamWriter = new XMLSecurityStreamWriter(outputProcessorChain);
+
+        xmlSecurityStreamWriter.writeStartElement(null, ""element"", ""http://element.ns"");
+        xmlSecurityStreamWriter.writeDefaultNamespace(""http://element.ns"");
+        xmlSecurityStreamWriter.writeStartElement(""childElement"");
+    }
+
",0,0
51,"+        size = ((DSAKey)privateKey).getParams().getQ().bitLength();
",1,0
52,"-    public boolean engineCanResolve(Attr uri, String baseURI) {
-        if (uri == null) {
+    public boolean engineCanResolveURI(ResourceResolverContext context) {
+        if (context.uriToResolve == null) {
",0,0
53,"-            if (XMLCipher.RSA_OAEP.equals(algorithm)
-                && (digestAlgorithm == null 
-                    || MessageDigestAlgorithm.ALGO_ID_DIGEST_SHA1.equals(digestAlgorithm))) {
-                try {
-                    if (requestedJCEProvider == null) {
-                        c = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"");
-                    } else {
-                        c = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"", requestedJCEProvider);
-                    }
-                } catch (Exception ex) {
-                    throw new XMLEncryptionException(""empty"", ex);
-                }
-            } else {
-                throw new XMLEncryptionException(""empty"", nsae);
-            }
+            c = constructCipher(algorithm, digestAlgorithm, nsae);
",0,0
54,"+import org.apache.xml.security.exceptions.XMLSecurityException;
+import org.apache.xml.security.signature.Manifest;
",0,1
55,"-        if (baseURI != null && baseURI.length() > 0) {
-            result.setSourceURI(baseURI.concat(uri.getNodeValue()));      
+        if (context.baseUri != null && context.baseUri.length() > 0) {
+            result.setSourceURI(context.baseUri.concat(context.uriToResolve));      
         } else {
-            result.setSourceURI(uri.getNodeValue());      
+            result.setSourceURI(context.uriToResolve);      
",0,0
56,"-        SIGN_KEYS[0] = TestUtils.getPrivateKey(""DSA"");
-        SIGN_KEYS[1] = TestUtils.getPrivateKey(""RSA"");
+        SIGN_KEYS[0] = TestUtils.getPrivateKey(""DSA"", 1024);
+        SIGN_KEYS[1] = TestUtils.getPrivateKey(""RSA"", 512);
",0,0
57,"+import org.apache.xml.security.utils.resolver.ResourceResolverContext;
",0,0
58,"-   /** Field _alreadyInitialized */
-   static boolean _alreadyInitialized = false;
-
    /** these are the system-wide resolvers */
-   static List _resolverVector = null;
+   private static List _resolverVector = new ArrayList(10);
    
-   static boolean allThreadSafeInList=true;
+   private static boolean allThreadSafeInList=true;
",1,0
59,"-                    UtfHelpper.writeCharToUtf8(c, writer);
+                    UtfHelpper.writeCodePointToUtf8(c, writer);
",1,0
60,"-                ""org.jcp.xml.dsig.internal.dom.DOMCanonicalXMLC14NMethod"");
+                ""org.apache.jcp.xml.dsig.internal.dom.DOMCanonicalXMLC14NMethod"");
",1,0
61,"-    
+
",0,0
62,"-                    KeyLength=""128""
+                    KeyLength=""0""
",1,0
63,"-        buf = (byte[])bufCache.get();
+        buf = new byte[size];
",1,0
64,"+import javax.xml.stream.XMLStreamException;
+import java.io.IOException;
+import java.io.Writer;
",1,0
65,"-    /**
-     * Constructs a new {@code ByteArrayOutputStream} with a default size of
-     * {@code size} bytes. If more than {@code size} bytes are written to this
-     * instance, the underlying byte array will expand.
-     *
-     * @param size
-     *            initial size for the underlying byte array, must be
-     *            non-negative.
-     * @throws IllegalArgumentException
-     *             if {@code size} < 0.
-     */
-    public UnsyncByteArrayOutputStream(int size) {
-        super();
-        if (size < 0) {
-            throw new IllegalArgumentException(""size must be >= 0"");
+    public void write(byte[] arg0) {
+        if ((VM_ARRAY_INDEX_MAX_VALUE - pos) < arg0.length) {
+            throw new OutOfMemoryError();
         }
-        buf = new byte[size];
-    }
-
-    private void expand(int i) {
-        /* Can the buffer handle @i more bytes, if not expand it */
-        if (count + i <= buf.length) {
-            return;
+        int newPos = pos + arg0.length;
+        if (newPos > size) {
+            expandSize(newPos);
         }
-
-        byte[] newbuf = new byte[(count + i) << 1];
-        System.arraycopy(buf, 0, newbuf, 0, count);
-        buf = newbuf;
-    }
-
-    /**
-     * Resets this stream to the beginning of the underlying byte array. All
-     * subsequent writes will overwrite any bytes previously stored in this
-     * stream.
-     */
-    public void reset() {
-        count = 0;
-    }
-
-    /**
-     * Returns the total number of bytes written to this stream so far.
-     *
-     * @return the number of bytes written to this stream.
-     */
-    public int size() {
-        return count;
+        System.arraycopy(arg0, 0, buf, pos, arg0.length);
+        pos = newPos;
",1,1
66,"-package org.jcp.xml.dsig.internal.dom;
+package org.apache.jcp.xml.dsig.internal.dom;
",1,0
67,"-            new Algorithm("""", ""HmacSHA224"", ""Mac"", 224, 0)
+            new Algorithm("""", ""HmacSHA224"", ""Mac"", 0, 0)
",1,1
68,"-            (new org.jcp.xml.dsig.internal.dom.XMLDSigRI(), 1);
+            (new org.apache.jcp.xml.dsig.internal.dom.XMLDSigRI(), 1);
",0,0
69,"-        Element objElem = DOMUtils.createElement
-            (ownerDoc, ""Object"", XMLSignature.XMLNS, dsPrefix);
-
-	// set attributes
-        DOMUtils.setAttributeID(objElem, ""Id"", id);
-	DOMUtils.setAttribute(objElem, ""MimeType"", mimeType);
-        DOMUtils.setAttribute(objElem, ""Encoding"", encoding);
-
-        // create and append any elements and mixed content, if necessary
-	for (int i = 0, size = content.size(); i < size; i++) {
-            XMLStructure object = (XMLStructure) content.get(i);
-            if (object instanceof DOMStructure) {
-                ((DOMStructure) object).marshal(objElem, dsPrefix, context);
-            } else {
-	        javax.xml.crypto.dom.DOMStructure domObject = 
-		    (javax.xml.crypto.dom.DOMStructure) object;
-		DOMUtils.appendChild(objElem, domObject.getNode());
+        Element objElem = objectElem != null ? objectElem : null;
+        if (objElem == null) {
+            objElem = DOMUtils.createElement(ownerDoc, ""Object"",
+                                             XMLSignature.XMLNS, dsPrefix);
+            // set attributes
+            DOMUtils.setAttributeID(objElem, ""Id"", id);
+            DOMUtils.setAttribute(objElem, ""MimeType"", mimeType);
+            DOMUtils.setAttribute(objElem, ""Encoding"", encoding);
+            // create and append any elements and mixed content, if necessary
+            for (int i = 0, size = content.size(); i < size; i++) {
+                XMLStructure object = (XMLStructure)content.get(i);
+                if (object instanceof DOMStructure) {
+                    ((DOMStructure)object).marshal(objElem, dsPrefix, context);
+                } else {
+                    javax.xml.crypto.dom.DOMStructure domObject = 
+                        (javax.xml.crypto.dom.DOMStructure)object;
+                    DOMUtils.appendChild(objElem, domObject.getNode());
+                }
",1,0
70,"+                    digestElement.setAttributeNS(
+                        Constants.NamespaceSpecNS,
+                        ""xmlns:"" + ElementProxy.getDefaultPrefix(Constants.SignatureSpecNS),
+                        Constants.SignatureSpecNS
+                    );
",1,1
71,"-    public XMLSignatureInput engineResolve(Attr uri, String baseURI) {
-        return this.input;
+    @Override
+    public XMLSignatureInput engineResolveURI(ResourceResolverContext context) {
+	    return new XMLSignatureInput(inStream);
",1,0
72,"-        resolver2.resolve(uri1, ""test2"");		
-        resolver.resolve(uri, ""test"");
-        resolver1.resolve(uri1, ""test1"");
+        resolver2.resolve(uri1, ""test2"", true);		
+        resolver.resolve(uri, ""test"", true);
+        resolver1.resolve(uri1, ""test1"", true);
",0,0
73,"-                        UtfHelpper.writeCharToUtf8(c, writer);
+                        UtfHelpper.writeCodePointToUtf8(c, writer);
",1,0
74,"+    private final SortedSet<Attr> result = new TreeSet<Attr>(COMPARE);
",0,0
75,"- * @author $Author$
",0,0
76,"-        AlgorithmParameterSpec paramSpec = constructBlockCipherParameters(algorithm, ivBytes);
+        
+        String blockCipherAlg = algorithm;
+        if (blockCipherAlg == null) {
+            blockCipherAlg = encMethodAlgorithm;
+        }
+        AlgorithmParameterSpec paramSpec = constructBlockCipherParameters(blockCipherAlg, ivBytes);
",1,1
77,"-        String uriNodeValue = uri.getNodeValue();
-        Document doc = uri.getOwnerElement().getOwnerDocument();
+        Document doc = context.attr.getOwnerElement().getOwnerDocument();
",0,0
78,"-        if (result == false) {    	  
+        if (!result) {    	  
",0,0
79,"-        public XMLSignatureInput engineResolve(
-            Attr uri, String BaseURI
+        @Override
+        public XMLSignatureInput engineResolveURI(
+            ResourceResolverContext context
         ) throws ResourceResolverException {
-            assertEquals(uriCompare, uri);
-            assertEquals(baseCompare,BaseURI);
+            assertEquals(uriCompare, context.uriToResolve);
+            assertEquals(baseCompare, context.baseUri);
",0,0
80,"-            UnicodeEscaper.outsideOf(32, 0x7f) 
+            JavaUnicodeEscaper.outsideOf(32, 0x7f) 
",1,0
81,"-import junit.framework.AssertionFailedError;
-
-import org.apache.commons.lang3.test.SystemDefaultsSwitch;
 import org.apache.commons.lang3.test.SystemDefaults;
+import org.apache.commons.lang3.test.SystemDefaultsSwitch;
",0,1
82,"-    private transient int thisYear;
",1,0
83,"+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang.enums;
+
+import junit.framework.TestCase;
+
+/**
+ * Test cases for the LANG-76 issue with {@link EnumUtils}.
+ *
+ * NOTE: this needs to be compiled with source/target versions set to 1.5
+ *       in order to replicate/test the issue properly
+ */
+public class EnumUtilsLang76Test extends TestCase {
+
+    public EnumUtilsLang76Test(String name) {
+        super(name);
+    }
+
+    /**
+     * Test LANG-76
+     */
+    public void test_EnumUtils_getEnum_LANG76() {
+        Object obj = EnumUtils.getEnum(TestEnum.class, ""1"");
+        assertNotNull(""Enum is not intialized"", obj);
+        assertEquals(""EnumUtilsLang76Test.TestEnum[1]"", obj.toString());
+    }
+
+    /** Test Enum for LANG-76 **/
+    public static final class TestEnum  extends Enum {
+        private static final long serialVersionUID = 1L;
+        public static final TestEnum ONE     = new TestEnum(""1"");
+        public static final TestEnum TWO     = new TestEnum(""2"");
+        public static final TestEnum THREE   = new TestEnum(""3"");
+
+        private TestEnum(String value) {
+            super(value);
+        }
+    }
+}
",0,1
84,"-     * <p>Compares two CharSequences, returning {@code true} if they are equal ignoring
-     * the case.</p>
+     * <p>Compares two CharSequences, returning {@code true} if they represent
+     * equal sequences of characters, ignoring case.</p>
",0,1
85,"-        assertEquals(""truncate ampm-4 failed"",
-                dateTimeParser.parse(""February 4, 2002 12:00:00.000""),
+        assertEquals(""round ampm-4 failed"",
+                dateTimeParser.parse(""February 4, 2002 00:00:00.000""),
",0,0
86,"-                }                
+                }
",0,0
87,"-                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')
-                                : Integer.toString(milliseconds);
+                                ? StringUtils.leftPad(Long.toString(milliseconds), count, '0')
+                                : Long.toString(milliseconds);
",1,1
88,"-    
+
",0,0
89,"+
+                // Check there's more than just an x after the &#
+                if(start == seqEnd) {
+                    return 0;
+                }
",1,0
90,"+     * @deprecated The design of this method is bad - see LANG-360. Instead, use identityToString(StringBuffer, Object).
",0,0
91,"-     *  may be null
+     *  may be null, but must not be empty
      * @return the random string
-     * @throws IllegalArgumentException if {@code count} &lt; 0.
+     * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.
",0,1
92,"+import java.util.Locale;
+
",0,0
93,"-     * StringUtils.isNumeric(null)   = false
-     * StringUtils.isNumeric("""")     = true
-     * StringUtils.isNumeric(""  "")   = true
-     * StringUtils.isNumeric(""123"")  = true
-     * StringUtils.isNumeric(""12 3"") = true
-     * StringUtils.isNumeric(""ab2c"") = false
-     * StringUtils.isNumeric(""12-3"") = false
-     * StringUtils.isNumeric(""12.3"") = false
+     * StringUtils.isNumericSpace(null)   = false
+     * StringUtils.isNumericSpace("""")     = true
+     * StringUtils.isNumericSpace(""  "")   = true
+     * StringUtils.isNumericSpace(""123"")  = true
+     * StringUtils.isNumericSpace(""12 3"") = true
+     * StringUtils.isNumericSpace(""ab2c"") = false
+     * StringUtils.isNumericSpace(""12-3"") = false
+     * StringUtils.isNumericSpace(""12.3"") = false
",0,0
94,"-    public static final FastDateFormat ISO8601_DATETIME_FORMAT
+    public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_FORMAT
",1,0
95,"+    /**
+     * Tests that a lookup object for system properties can deal with a full
+     * replacement of the system properties object. This test is related to
+     * LANG-1055.
+     */
     @Test
-    public void testSystemPropertiesLookupNotSingleton() {
+    public void testSystemPropertiesLookupReplacedProperties() {
+        Properties oldProperties = System.getProperties();
         final String osName = ""os.name"";
-        final String originalOsName = System.getProperty(osName);
+        final String newOsName = oldProperties.getProperty(osName) + ""_changed"";
 
-        StrLookup<String> properties1 = StrLookup.systemPropertiesLookup();
-        assertEquals(originalOsName, properties1.lookup(osName));
+        StrLookup<String> sysLookup = StrLookup.systemPropertiesLookup();
+        Properties newProps = new Properties();
+        newProps.setProperty(osName, newOsName);
+        System.setProperties(newProps);
+        try {
+            assertEquals(""Changed properties not detected"", newOsName, sysLookup.lookup(osName));
+        } finally {
+            System.setProperties(oldProperties);
+        }
+    }
 
-        final String differentOsName = ""HAL-9000"";
-        System.setProperty(osName, differentOsName);
-        StrLookup<String> properties2 = StrLookup.systemPropertiesLookup();
+    /**
+     * Tests that a lookup object for system properties sees changes on system
+     * properties. This test is related to LANG-1141.
+     */
+    @Test
+    public void testSystemPropertiesLookupUpdatedProperty() {
+        final String osName = ""os.name"";
+        String oldOs = System.getProperty(osName);
+        final String newOsName = oldOs + ""_changed"";
 
-        assertEquals(originalOsName, properties1.lookup(osName));
-        assertEquals(differentOsName, properties2.lookup(osName));
+        StrLookup<String> sysLookup = StrLookup.systemPropertiesLookup();
+        System.setProperty(osName, newOsName);
+        try {
+            assertEquals(""Changed properties not detected"", newOsName, sysLookup.lookup(osName));
+        } finally {
+            System.setProperty(osName, oldOs);
+        }
",0,1
96,"-        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());
+        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());
",0,0
97,"+     * @deprecated - as of 4.0, ISO_DATETIME_FORMAT will be replaced by ISO8601_DATETIME_FORMAT.
+     */
+    @Deprecated
+    public static final FastDateFormat ISO_DATETIME_FORMAT = ISO8601_DATETIME_FORMAT;
+
+    /**
",1,1
98,"-    // Tests LANG-59
-    public void testLang59() throws Exception {
-        // truncate 2004-10-31 01:00:00 MDT
-        Date oct31_01MDT = new Date(1099206000000L);
-        Date result = DateUtils.truncate(oct31_01MDT, Calendar.HOUR_OF_DAY);
-        assertEquals(oct31_01MDT, result); 
-    }
-
",0,0
99,"+      <name>Daniel Trebbien</name>
+    </contributor>
+    <contributor>
",0,0
100,"-                    end = Integer.MAX_VALUE;
+                    end = Character.MAX_CODE_POINT;
",1,1
101,"+    [LANG-703] StringUtils.join throws NPE when toString returns null for one of objects in collection
",0,1
102,"-        this.validateEmptyReflectionRegistry();
+        this.validateEmptyToStringStyleRegistry();
",0,0
103,"-        assertEquals(true, StringUtils.isAlpha(""""));
+        assertEquals(false, StringUtils.isAlpha(""""));
",0,1
104,"-        } finally {
-            this.unregisterObject();
",1,0
105,"-                        && isDigits(numeric.substring(1))
-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
",1,1
106,"+        // set the initial index beyond the end of the string
+        // this is to allow for the initial index decrement/increment
",0,1
107,"-        
-        try {
-            FieldUtils.getField(null, ""none"");
-            fail(""null class should cause an IllegalArgumentException"");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
-
-        try {
-            FieldUtils.getField(PublicChild.class, null);
-            fail(""null field name should cause an IllegalArgumentException"");
-        } catch (IllegalArgumentException e) {
-            // expected
-        }
",0,0
108,"-        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());
+        assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());
",0,0
109,"+    /** Test for LANG-76 **/
+    public void testGetEnum_LANG76() {
+        Object obj = EnumUtils.getEnum(Lang76Enum.class, ""1"");
+        assertNotNull(obj);
+        assertEquals(""EnumUtilsTest.Lang76Enum[1]"", obj.toString());
+    }
+
+    /** Test Enum for LANG-76 **/
+    public static final class Lang76Enum  extends Enum {
+        public static final Lang76Enum ONE     = new Lang76Enum(""1"");
+        public static final Lang76Enum TWO     = new Lang76Enum(""2"");
+        public static final Lang76Enum THREE   = new Lang76Enum(""3"");
+
+        private Lang76Enum(String suit) {
+            super(suit);
+        }
+    }
",0,0
110,"+
+        // Test null safety inside arrays - LANG-552
+        assertEquals(StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{null}),""aba"");
+        assertEquals(StringUtils.replaceEach(""aba"", new String[]{""a"", ""b""}, new String[]{""c"", null}),""cbc"");
",0,0
111,"-    static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,
-            int milliseconds, final boolean padWithZeros) {
+    static String format(final Token[] tokens, final long years, final long months, final long days, final long hours, final long minutes, final long seconds,
+            long milliseconds, final boolean padWithZeros) {
",1,1
112,"-        super(object);
+        super(checkNotNull(object));
",1,0
113,"-    public static Locale toLocale(String str) {
+    public static Locale toLocale(final String str) {
",0,1
114,"-        super.appendDetail(buffer, fieldName, array);
+        super.reflectionAppendArrayDetail(buffer, fieldName, array);
",1,0
115,"+            new OctalUnescaper(),     // .between('\1', '\377'),
",1,0
116,"-            if (lhs instanceof java.math.BigDecimal && rhs instanceof java.math.BigDecimal) {
-                isEquals = (((java.math.BigDecimal)lhs).compareTo((java.math.BigDecimal)rhs) == 0);
-            } else {
-                // The simple case, not an array, just test the element
-                isEquals = lhs.equals(rhs);
-            }
+            // The simple case, not an array, just test the element
+            isEquals = lhs.equals(rhs);
",1,0
117,"-            escapeJavaStyleString(writer, str, escapeSingleQuotes);
+            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
",1,0
118,"+    <action issue=""LANG-971"" type=""fix"" dev=""sebb"">NumberUtils#isNumber(String) fails to reject invalid Octal numbers</action>
",0,1
119,"-    public static final FastDateFormat ISO8601_DATETIME_TIME_ZONE_FORMAT
+    public static final FastDateFormat ISO_8601_EXTENDED_DATETIME_TIME_ZONE_FORMAT
",1,0
120,"-     * @param <C> the list type
      * @param map  the map to wrap, must not be null
-     * @param listClazz  the collection class
-     * @param initialListCapacity  the initial size of the values list
-     * @throws NullPointerException  if the map is null
-     * @throws IllegalArgumentException  if initialListCapacity is negative
+     * @throws NullPointerException if the map is null
      */
-    protected <C extends List<V>> AbstractListValuedMap(final Map<K, ? super C> map, Class<C> listClazz,
-                                                        final int initialListCapacity) {
-        super(map, listClazz, initialListCapacity);
+    protected AbstractListValuedMap(final Map<K, ? extends List<V>> map) {
+        super(map);
+    }
+
+    // -----------------------------------------------------------------------
+    @Override
+    @SuppressWarnings(""unchecked"")
+    protected Map<K, List<V>> getMap() {
+        return (Map<K, List<V>>) super.getMap();
",1,0
121,"+        if (iterator == null) {
+            return false;
+        }
",1,0
122,"-        put(key, value);
+        super.put(key, value);
",1,0
123,"-     * Constructs a new <code>CollatingIterator</code>.  Natural sort order
-     * will be used, and child iterators will have to be manually added 
+     * Constructs a new <code>CollatingIterator</code>. A comparator must be
+     * set by calling {@link #setComparator(Comparator)} before invoking
+     * {@link #hasNext()}, or {@link #next()} for the first time. Child
+     * iterators will have to be manually added using the
",0,0
124,"-            coll.add(value);
+            coll.add((V) value);
",0,0
125,"+    public void testTransformedSet_decorateTransform() {
+        Set originalSet = new HashSet();
+        Object[] els = new Object[] {""1"", ""3"", ""5"", ""7"", ""2"", ""4"", ""6""};
+        for (int i = 0; i < els.length; i++) {
+            originalSet.add(els[i]);
+        }
+        Set set = TransformedSet.decorateTransform(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);
+        assertEquals(els.length, set.size());
+        for (int i = 0; i < els.length; i++) {
+            assertEquals(true, set.contains(new Integer((String) els[i])));
+            assertEquals(false, set.contains(els[i]));
+        }
+        
+        assertEquals(false, set.remove(els[0]));
+        assertEquals(true, set.remove(new Integer((String) els[0])));
+    }
+
",0,1
126,"-    @SuppressWarnings(""unchecked"")
-    public void testListValuedMapAdd() {
-        final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();
-        assertTrue(listMap.get((K) ""whatever"") instanceof List);
-        List<V> list = listMap.get((K) ""A"");
-        list.add((V) ""a1"");
-        assertEquals(1, listMap.size());
-        assertTrue(listMap.containsKey(""A""));
-    }
-
-    @SuppressWarnings(""unchecked"")
-    public void testListValuedMapAddViaListIterator() {
-        final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();
-        ListIterator<V> listIt = listMap.get((K) ""B"").listIterator();
-        assertFalse(listIt.hasNext());
-        listIt.add((V) ""b1"");
-        listIt.add((V) ""b2"");
-        listIt.add((V) ""b3"");
-        assertEquals(3, listMap.size());
-        assertTrue(listMap.containsKey(""B""));
-        // As ListIterator always adds before the current cursor
-        assertFalse(listIt.hasNext());
-    }
-
-    @SuppressWarnings(""unchecked"")
-    public void testListValuedMapRemove() {
-        final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();
-        List<V> list = listMap.get((K) ""A"");
-        list.add((V) ""a1"");
-        list.add((V) ""a2"");
-        list.add((V) ""a3"");
-        assertEquals(3, listMap.size());
-        assertEquals(""a1"", list.remove(0));
-        assertEquals(2, listMap.size());
-        assertEquals(""a2"", list.remove(0));
-        assertEquals(1, listMap.size());
-        assertEquals(""a3"", list.remove(0));
-        assertEquals(0, listMap.size());
-        assertFalse(listMap.containsKey(""A""));
-    }
-
-    @SuppressWarnings(""unchecked"")
-    public void testListValuedMapRemoveViaListIterator() {
-        final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();
-        ListIterator<V> listIt = listMap.get((K) ""B"").listIterator();
-        listIt.add((V) ""b1"");
-        listIt.add((V) ""b2"");
-        assertEquals(2, listMap.size());
-        assertTrue(listMap.containsKey(""B""));
-        listIt = listMap.get((K) ""B"").listIterator();
-        while (listIt.hasNext()) {
-            listIt.next();
-            listIt.remove();
-        }
-        assertFalse(listMap.containsKey(""B""));
-        listIt.add((V) ""b1"");
-        listIt.add((V) ""b2"");
-        assertTrue(listMap.containsKey(""B""));
-        assertEquals(2, listMap.get((K) ""B"").size());
-    }
-
-    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
-    public void testEqualsHashCodeContract() {
-        MultiValuedMap map1 = new MultiValuedHashMap();
-        MultiValuedMap map2 = new MultiValuedHashMap();
-
-        map1.put(""a"", ""a1"");
-        map1.put(""a"", ""a2"");
-        map2.put(""a"", ""a1"");
-        map2.put(""a"", ""a2"");
-        assertEquals(map1, map2);
-        assertEquals(map1.hashCode(), map2.hashCode());
-
-        map2.put(""a"", ""a2"");
-        assertNotSame(map1, map2);
-        assertNotSame(map1.hashCode(), map2.hashCode());
-    }
-
-    @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
-    public void testListValuedMapEqualsHashCodeContract() {
-        ListValuedMap map1 = MultiValuedHashMap.listValuedHashMap();
-        ListValuedMap map2 = MultiValuedHashMap.listValuedHashMap();
-
-        map1.put(""a"", ""a1"");
-        map1.put(""a"", ""a2"");
-        map2.put(""a"", ""a1"");
-        map2.put(""a"", ""a2"");
-        assertEquals(map1, map2);
-        assertEquals(map1.hashCode(), map2.hashCode());
-
-        map1.put(""b"", ""b1"");
-        map1.put(""b"", ""b2"");
-        map2.put(""b"", ""b2"");
-        map2.put(""b"", ""b1"");
-        assertNotSame(map1, map2);
-        assertNotSame(map1.hashCode(), map2.hashCode());
-    }
-
",0,0
127,"-        return getMap().hashCode();
+        return asMap().hashCode();
",1,0
128,"-        int total = 0;
-        for (int i = 0; i < keys.length; i++) {
-            if (keys[i] != null) {
-                total ^= keys[i].hashCode();
-            }
-        }
-        hashCode = total;
+        calculateHashCode(keys);
",0,0
129,"-        return ListUtils.retainAll(collection, remove);
+        return ListUtils.removeAll(collection, remove);
",1,1
130,"+     * <p>
+     * <b>WARNING:</b> from v3.2.2 onwards this method will return a {@code Factory}
+     * that will throw an {@link UnsupportedOperationException} when trying to serialize
+     * or de-serialize it to prevent potential remote code execution exploits.
+     * <p>
+     * In order to re-enable serialization support the following system property
+     * can be used (via -Dproperty=true):
+     * <pre>
+     * org.apache.commons.collections.enableUnsafeSerialization
+     * </pre>
",0,0
131,"-      the contract of ""Object#equals"".
+      the contract of ""Object#equals"". Added note to javadoc of
+      ""AbstractCollectionDecorator#equals(Object)"" that the implementation might
+      break symmetry requirement of the ""Collection#equals"" contract.
",0,1
132,"- * 
+ * <p>
+ * <b>WARNING:</b> from v3.2.2 onwards this class will throw an
+ * {@link UnsupportedOperationException} when trying to serialize or
+ * de-serialize an instance to prevent potential remote code execution exploits.
+ * <p>
+ * In order to re-enable serialization support for {@code InstantiateTransformer}
+ * the following system property can be used (via -Dproperty=true):
+ * <pre>
+ * org.apache.commons.collections.enableUnsafeSerialization
+ * </pre>
+ *
",0,0
133,"+     * @throws NullPointerException if a key or value in the provided map is {@code null}
",0,1
134,"-    private final Map<K, Collection<V>> map;
+    private transient Map<K, Collection<V>> map;
",1,0
135,"-    @SuppressWarnings({ ""unchecked"", ""rawtypes"" }) // we don't know the types due to wildcards in the signature
-    public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b, final Equator<?> equator) {
+    public static <E> boolean isEqualCollection(final Collection<? extends E> a,
+                                                final Collection<? extends E> b,
+                                                final Equator<? super E> equator) {
",1,0
136,"-public class InstantiateTransformer<T> implements Transformer<Class<? extends T>, T>, Serializable {
-
-    /** The serial version */
-    private static final long serialVersionUID = 3786388740793356347L;
+public class InstantiateTransformer<T> implements Transformer<Class<? extends T>, T> {
",1,0
137,"+    @SuppressWarnings(""unchecked"")
     public void testKeyContainsValue() {
-        final MultiValueMap map = createTestMap(HashSet.class);
-        assertTrue(map.containsValue(""one"", ""uno""));
-        assertTrue(map.containsValue(""one"", ""un""));
-        assertTrue(map.containsValue(""two"", ""dos""));
-        assertTrue(map.containsValue(""two"", ""deux""));
-        assertTrue(map.containsValue(""three"", ""tres""));
-        assertTrue(map.containsValue(""three"", ""trois""));
-        assertFalse(map.containsValue(""four"", ""quatro""));
+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);
+        assertTrue(map.containsValue((K) ""one"", ""uno""));
+        assertTrue(map.containsValue((K) ""one"", ""un""));
+        assertTrue(map.containsValue((K) ""two"", ""dos""));
+        assertTrue(map.containsValue((K) ""two"", ""deux""));
+        assertTrue(map.containsValue((K) ""three"", ""tres""));
+        assertTrue(map.containsValue((K) ""three"", ""trois""));
+        assertFalse(map.containsValue((K) ""four"", ""quatro""));
",0,1
138,"-        final MultiValuedMap<String, String> map = new MultiValuedHashMap<String, String>();
+        final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<String, String>();
",0,0
139,"+     * @param equator  the equator to use for comparison
+     * @since 4.0
      */
-    public EqualPredicate(Object object) {
+    public EqualPredicate(T object, Equator<T> equator) {
",1,1
140,"-        final MultiValuedMap<String, String> map = new MultiValuedHashMap<String, String>();
+        final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<String, String>();
",0,0
141,"-            System.clearProperty(InvokerTransformer.DESERIALIZE);
+            System.clearProperty(FunctorUtils.UNSAFE_SERIALIZABLE_PROPERTY);
",0,1
142,"-    
+
+    // COLLECTIONS-294
+    public void testLocaleIndependence() {
+        Locale orig = Locale.getDefault();
+        Locale[] locales = { Locale.ENGLISH, new Locale(""tr""), Locale.getDefault() };
+        String[][] data = { 
+            { ""i"", ""I"" },
+            { ""\u03C2"", ""\u03C3"" },
+            { ""\u03A3"", ""\u03C2"" },
+            { ""\u03A3"", ""\u03C3"" },
+        };
+        try {
+            for (int i = 0; i < locales.length; i++) {
+                Locale.setDefault(locales[i]);
+                for (int j = 0; j < data.length; j++) {
+                    assertTrue(""Test data corrupt: "" + j, data[j][0].equalsIgnoreCase(data[j][1]));
+                    CaseInsensitiveMap map = new CaseInsensitiveMap();
+                    map.put(data[j][0], ""value"");
+                    assertEquals(Locale.getDefault() + "": "" + j, ""value"", map.get(data[j][1]));
+                }
+            }
+        } finally {
+            Locale.setDefault(orig);
+        }
+    }
+
",0,0
143,"-    
+
+    @SuppressWarnings(""unchecked"")
     public void testIterator_Key() {
-        MultiValueMap map = new MultiValueMap();
+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();
         assertEquals(false, map.iterator(""A"").hasNext());
-        map.put(""A"", ""AA"");
-        Iterator it = map.iterator(""A"");
+        map.put((K) ""A"", ""AA"");
+        Iterator<?> it = map.iterator(""A"");
",0,0
144,"-        if (deserializeProperty == null || !deserializeProperty.equalsIgnoreCase(""true"")) {
-            throw new UnsupportedOperationException(""Deserialization of InvokerTransformer is disabled, "");
+        if (!""true"".equalsIgnoreCase(deserializeProperty)) {
+            throw new UnsupportedOperationException(
+                    ""Deserialization of InvokerTransformer is disabled for security reasons. "" +
+                    ""To re-enable it set system property '"" + DESERIALIZE + ""' to 'true'"");
",1,0
145,"+    @SuppressWarnings(""unchecked"")
     public void testRemove_KeyItem() {
-        MultiValueMap map = new MultiValueMap();
-        map.put(""A"", ""AA"");
-        map.put(""A"", ""AB"");
-        map.put(""A"", ""AC"");
+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();
+        map.put((K) ""A"", ""AA"");
+        map.put((K) ""A"", ""AB"");
+        map.put((K) ""A"", ""AC"");
",0,0
146,"-            if (nextIndex == currentIndex) {
-                // remove() following previous()
-                next = next.next();
-                parent.remove(currentIndex);
-            } else {
+            parent.remove(currentIndex);
+            if (nextIndex != currentIndex) {
                 // remove() following next()
-                parent.remove(currentIndex);
",1,1
147,"-        assertEquals(new MultiValueMap(), map);
+        assertEquals(new MultiValueMap<K, V>(), map);
",0,0
148,"-/**
- * Entry point for all Collections project tests.
- * 
- * @version $Revision$ $Date$
- * 
- * @author Stephen Colebourne
- */
-public class TestAllPackages extends TestCase {
-    public TestAllPackages(String testName) {
+public class TestInstantiateTransformer extends AbstractTestSerialization {
+
+    // conventional
+    // ------------------------------------------------------------------------
+
+    public TestInstantiateTransformer(String testName) {
",0,0
149,"-            if (list1.contains(e)) {
+            if (copyOfList1.contains(e)) {
                 result.add(e);
+                copyOfList1.remove(e);
",1,0
150,"+    }
+
+    public void testTransformedBag_decorateTransform() {
+        Bag originalBag = new HashBag();
+        Object[] els = new Object[] {""1"", ""3"", ""5"", ""7"", ""2"", ""4"", ""6""};
+        for (int i = 0; i < els.length; i++) {
+            originalBag.add(els[i]);
+        }
+        Bag bag = TransformedBag.decorateTransform(originalBag, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);
+        assertEquals(els.length, bag.size());
+        for (int i = 0; i < els.length; i++) {
+            assertEquals(true, bag.contains(new Integer((String) els[i])));
+            assertEquals(false, bag.contains(els[i]));
+        }
         
+        assertEquals(false, bag.remove(els[0]));
+        assertEquals(true, bag.remove(new Integer((String) els[0])));
",0,1
151,"-        return new MultiValuedHashMap<K, V>();
+        return new ArrayListValuedHashMap<K, V>();
",0,0
152,"-     * Sets the {@link Comparator} by which collation occurs.
+     * Sets the {@link Comparator} by which collation occurs. If you
+     * would like to use the natural sort order (or, in other words,
+     * if the elements in the iterators are implementing the
+     * {@link java.lang.Comparable} interface), then use the
+     * {@link org.apache.commons.collections.comparators.ComparableComparator}.
",0,0
153,"-    private MultiValueMap createTestMap(Class collectionClass) {
-        final MultiValueMap map = MultiValueMap.decorate(new HashMap(), collectionClass);
-        map.put(""one"", ""uno"");
-        map.put(""one"", ""un"");
-        map.put(""two"", ""dos"");
-        map.put(""two"", ""deux"");
-        map.put(""three"", ""tres"");
-        map.put(""three"", ""trois"");
+    @SuppressWarnings(""unchecked"")
+    private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(Class<C> collectionClass) {
+        final MultiValueMap<K, V> map = MultiValueMap.decorate(new HashMap<K, C>(), collectionClass);
+        map.put((K) ""one"", (V) ""uno"");
+        map.put((K) ""one"", (V) ""un"");
+        map.put((K) ""two"", (V) ""dos"");
+        map.put((K) ""two"", (V) ""deux"");
+        map.put((K) ""three"", (V) ""tres"");
+        map.put((K) ""three"", (V) ""trois"");
",0,1
154,"-        for (final Collection<? extends E> item : all) {
+        for (final Collection<E> item : all) {
",1,0
155,"-    <action issue=""COLLECTIONS-266"" dev=""bayard"" type=""fix"" due-to=""Joerg Schaible"">
-      ""MultiKey"" will now be correctly serialized/de-serialized.
-    </action>
",0,1
156,"-     * Adds an element to the end of the list if it is not already present.
+     * Adds a collection of objects to the end of the list avoiding duplicates.
+     * <p>
+     * Only elements that are not already in this list will be added, and
+     * duplicates from the specified collection will be ignored.
",0,1
157,"+    //-----------------------------------------------------------------------
",0,0
158,"+import org.apache.commons.collections4.ListUtils;
",1,0
159,"+        
+        // bug in IBM JDK: IBM J9 VM build 2.4, JRE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260sr12-20121024_126067
+        // a call to values() on an empty map retrieved via TreeMap#headMap or tailMap
+        // will render the values view unusable: resulting in NullPointExceptions or missing values
+        // it will also not recover, as the value view is cached internally
+        values = getMap().values();
+        
",0,0
160,"+- FIX: Use of a shared DocumentBuilder causes SAXException during parallel resolutions (IVY-1147)
",0,0
161,"+	Ales Nosek
",0,0
162,"+<!--
+   Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+-->
+<ivy-module version=""1.0"">
+    <info organisation=""org""
+          module=""mod1""
+          revision=""2.0""
+    />
+    <dependencies>
+        <dependency org=""org"" name=""foo-bar"" rev=""1.2.3"" />
+    </dependencies>
+</ivy-module>
",0,0
163,"+        
+        public MacroRecord recordChild(String name, Object object) {
+            MacroRecord child = recordChild(name);
+            child.object = object;
+            return child;
+        }
",1,0
164,"-        addLockStrategy(""artifact-lock"", new ArtifactLockStrategy(debugLocking()));
+        addLockStrategy(""artifact-lock"", new CreateFileLockStrategy(debugLocking()));
+        addLockStrategy(""artifact-lock-nio"", new NIOFileLockStrategy(debugLocking()));
",1,1
165,"-import java.text.ParseException;
",0,0
166,"+        Map allAttributes = new HashMap();
+        allAttributes.putAll(md.getQualifiedExtraAttributes());
+        allAttributes.putAll(askedMrid.getQualifiedExtraAttributes());
+        
",1,0
167,"-            // ok => should raised an exception
+            // ok => should raise an exception
",0,0
168,"-            String org = attributes.getValue(""org"");
+            String org = _ivy.substitute(attributes.getValue(""org""));
             org = org == null ? PatternMatcher.ANY_EXPRESSION : org;
-            String module = attributes.getValue(""module"");
+            String module = _ivy.substitute(attributes.getValue(""module""));
",1,0
169,"-                if (rmr.getDescriptor().isDefault() && rmr.getResolver() != this) {
-                    Message.verbose(""\t""+getName()+"": found revision in cache: ""+mrid+"": but it's a default one, maybe we can find a better one"");
+                if (rmr.getDescriptor().isDefault() && rmr.getResolver() != this && isResolved(data, resolvedMrid)) {
+                    Message.verbose(""\t""+getName()+"": found revision in cache: ""+mrid+"" (resolved by ""+rmr.getResolver().getName()+""): but it's a default one, maybe we can find a better one"");
",1,0
170,"+<!--
+   Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.    
+-->
+<ivy-module version=""2.0"">
+    <info organisation=""myorg"" module=""modB"" branch=""trunk"" revision=""5"" />
+    <configurations>
+      <conf name=""default""/>
+    </configurations>
+    <publications>
+    </publications>
+    <dependencies>
+      <dependency org=""myorg"" name=""modA"" branch=""trunk"" rev=""latest.integration"" conf=""default->default""/>
+    </dependencies>
+</ivy-module>
",0,0
171,"+import org.apache.tools.ant.DefaultLogger;
",0,0
172,"-    private final static String ANY_NON_SPECIAL_PATTERN = ""[^"" + SEP_PATTERN + OPEN_INC_PATTERN
+    private final static String ANY_NON_SPECIAL_PATTERN = ""[^\\s"" + SEPARATOR + OPEN_INC_PATTERN
",1,0
173,"+import org.apache.ivy.plugins.version.VersionMatcher;
",1,0
174,"+    public void testResolveContradictoryConflictResolution3() throws Exception {
+        // mod 1.2 v2.0 should be selected (despite conflict manager in 4.1, because of force in 10.1)
+        // mod10.1 v 1.3 depends on 
+        //   - mod1.2 v 2.0 and forces it
+        //   - mod4.1 v 4.4
+        // mod4.1 v 4.4 depends on 
+        //   - mod1.2 v 2.0 but selects mod1.2 v 2.1
+        //   - mod3.1 v 1.1 which depends on mod1.2 v 2.1
+        ResolveReport report = _ivy.resolve(new File(""test/repositories/2/mod10.1/ivy-1.3.xml"").toURL(),
+                null, new String[] {""*""}, _cache, null, true);
+        
+        IvyNode[] evicted = report.getConfigurationReport(""default"").getEvictedNodes();
+        assertEquals(1, evicted.length);
+        assertEquals(ModuleRevisionId.newInstance(""org1"", ""mod1.2"", ""2.1""), evicted[0].getResolvedId());
+    }
+    
",0,0
175,"- String[] dependencyConfigurations = dd.getDependencyConfigurations(conf, getRequestedConf());
+            String[] dependencyConfigurations = dd.getDependencyConfigurations(conf, getRequestedConf());
",0,0
176,"-- FIX: Retrieve Ant task ignores resolveId attribute (IVY-522)
+- FIX: Retrieve Ant task ignores resolveId attribute (IVY-522) (thanks to Scott Goldstein)
",0,0
177,"+        } catch (URISyntaxException e) {
+            IOException ex = new IOException(""impossible to get "" + source + "" on "" + getHost()
+                + (e.getMessage() != null ? "": "" + e.getMessage() : """"));
+            ex.initCause(e);
+            throw ex;
",1,0
178,"-        assertFalse(cacheManager.getIvyFileInCache(
-            ModuleRevisionId.newInstance(""org1"", ""mod1.2"", ""2.0"")).exists());
",0,0
179,"+            }
+
+            public DependencyResolver getArtifactResolver() {
+                return rmr.getArtifactResolver();
",1,0
180,"+    private static final class Depender {
+        private DependencyDescriptor dd;
+        private String dependerConf;
+        
+        public Depender(DependencyDescriptor dd, String dependerConf) {
+            this.dd = dd;
+            this.dependerConf = dependerConf;
+        }
+    }
+    
",1,0
181,"-        return usage.getRootModuleConfigurations();
+        Set confs = getRootModuleConfigurationsSet();
+        return (String[]) confs.toArray(new String[confs.size()]);
+    }
+
+    /**
+     * Returns the root module configurations in which this dependency is required
+     * 
+     * @return
+     */
+    public Set getRootModuleConfigurationsSet() {
+        Set confs = new LinkedHashSet();
+        addAllIfNotNull(confs, usage.getRootModuleConfigurations());
+        for (Iterator iterator = mergedUsages.values().iterator(); iterator.hasNext();) {
+            IvyNodeUsage usage = (IvyNodeUsage) iterator.next();
+            addAllIfNotNull(confs, usage.getRootModuleConfigurations());
+        }
+        return confs;
",1,0
182,"-public class IvyExtractFromSources extends IvyTask {
+public class IvyExtractFromSources extends Task {
",0,0
183,"-    private boolean hasLock(File file) {
-        Integer c = (Integer) currentLockCounters.get(file);
-        return c != null && c.intValue() > 0;
+    /** Determine the state of the lockfile.
+     * 
+     * Must be called from within a synchronized block.
+     * 
+     * Three possibilities exist:
+     *  - The lock is held by the current thread (>0)
+     *  - The lock is held by one or more different threads (-1)
+     *  - The lock is not held at all (0).
+     * 
+     * @param file file to lock
+     * @param forThread thread for which lock status is being queried
+     */
+    private int hasLock(File file, Thread forThread) {
+        Map locksPerThread = (Map) currentLockHolders.get(file);
+        if (locksPerThread == null) {
+            return 0;
+        }
+        if (locksPerThread.isEmpty()) {
+            return 0;
+        }
+        Integer counterObj = (Integer) locksPerThread.get(forThread);
+        int counter = counterObj == null ? 0 : counterObj.intValue();
+        if (counter > 0) {
+            return counter;
+        } else {
+            return -1;
+        }
",1,0
184,"-	You can use it especially with myconf1 and myconf2, and myconf4 is not too bad too.
+	You can use it especially with myconf1 &amp; myconf2, and myconf4 is not too bad too.
",0,0
185,"-import org.apache.ivy.core.module.descriptor.Artifact;
-import org.apache.ivy.core.module.descriptor.Configuration;
+import org.apache.ivy.core.module.descriptor.*;
 import org.apache.ivy.core.module.descriptor.Configuration.Visibility;
-import org.apache.ivy.core.module.descriptor.DefaultArtifact;
-import org.apache.ivy.core.module.descriptor.DefaultDependencyArtifactDescriptor;
-import org.apache.ivy.core.module.descriptor.DefaultDependencyDescriptor;
-import org.apache.ivy.core.module.descriptor.DefaultExcludeRule;
-import org.apache.ivy.core.module.descriptor.DefaultModuleDescriptor;
-import org.apache.ivy.core.module.descriptor.DependencyDescriptor;
-import org.apache.ivy.core.module.descriptor.ExtraInfoHolder;
-import org.apache.ivy.core.module.descriptor.License;
-import org.apache.ivy.core.module.descriptor.MDArtifact;
-import org.apache.ivy.core.module.descriptor.ModuleDescriptor;
-import org.apache.ivy.core.module.descriptor.OverrideDependencyDescriptorMediator;
",0,0
186,"-        _selected.put(new ModuleIdConf(moduleId, rootModuleConf), new HashSet(resolved));
+        _selectedDeps.put(new ModuleIdConf(moduleId, rootModuleConf), new HashSet(resolved));
+    }
+    
+    public Collection getEvictedNodes(ModuleId mid, String rootModuleConf) {
+        Collection resolved = (Collection)_evictedDeps.get(new ModuleIdConf(mid, rootModuleConf));
+        Set ret = new HashSet();
+        if (resolved != null) {
+            for (Iterator iter = resolved.iterator(); iter.hasNext();) {
+                IvyNode node = (IvyNode)iter.next();
+                ret.add(node.getRealNode());
+            }
+        }
+        return ret;
+    }
+    public Collection getEvictedRevisions(ModuleId mid, String rootModuleConf) {
+        Collection resolved = (Collection)_evictedDeps.get(new ModuleIdConf(mid, rootModuleConf));
+        if (resolved == null) {
+            return new HashSet();
+        } else {
+            Collection ret = new HashSet();
+            for (Iterator iter = resolved.iterator(); iter.hasNext();) {
+                IvyNode node = (IvyNode)iter.next();
+                ret.add(node.getRealNode().getResolvedId());
+            }
+            return ret;
+        }
+    }
+
+    public void setEvictedNodes(ModuleId moduleId, String rootModuleConf, Collection evicted) {
+        _evictedDeps.put(new ModuleIdConf(moduleId, rootModuleConf), new HashSet(evicted));
",1,0
187,"-        return (String[]) orgs.toArray(new String[orgs.size()]);
+
+        return (String[]) entries.toArray(new String[entries.size()]);
",1,0
188,"+ 
",0,0
189,"-            String[] confs = splitConfs(_conf);
-            Collection all = new LinkedHashSet();
-            for (int i = 0; i < confs.length; i++) {
-                Artifact[] artifacts = parser.getArtifacts(new ModuleId(_organisation, _module), confs[i], _cache);
-                all.addAll(Arrays.asList(artifacts));
-            }
-            for (Iterator iter = all.iterator(); iter.hasNext();) {
-                Artifact artifact = (Artifact)iter.next();
-                if (_artifactFilter.accept(artifact)) {
-                    path.createPathElement().setLocation(ivy.getArchiveFileInCache(_cache, artifact));
-                }
+            for (Iterator iter = getPaths().iterator(); iter.hasNext();) {
+                String p = (String)iter.next();
+                path.createPathElement().setLocation(new File(getCache(), p));
",1,0
190,"+<ivy-module version=""1.0"">
+	<info organisation=""org3""
+	       module=""mod3.2""
+	       revision=""1.4""
+	       status=""integration""
+	/>
+	<dependencies>
+		<dependency org=""org1"" name=""mod1.2"" rev=""2.0"" force=""true""/>
+		<dependency org=""org3"" name=""mod3.1"" rev=""1.1""/>
+	</dependencies>
+</ivy-module>
",0,0
191,"+    private static final String NO_REVISION = ""[[NONE]]"";
",1,0
192,"-        String baseURL = IvyPatternHelper.substitute(this.resourceURL, this.mr.getOrganisation(),
-          this.mr.getName(), this.mr.getRevision(), null, null, null, null,
-          this.mr.getAttributes(), null);
+        String baseURL = IvyPatternHelper.substitute(resourceURL, mr.getOrganisation(),
+                mr.getName(), mr.getRevision(), null, null, null, null,
+                mr.getQualifiedExtraAttributes(), null);
",1,0
193,"-import junit.framework.TestCase;
-
 import org.apache.ivy.core.IvyContext;
+import org.apache.ivy.core.module.descriptor.DefaultModuleDescriptor;
",0,0
194,"+	Wei Chen
",0,1
195,"+    /**
+     * List modules matching a given criteria, available in the given dependency resolver.
+     * <p>
+     * ModuleRevisionId are returned in the system namespace.
+     * </p>
+     *  
+     * @param resolver the resolver in which modules should looked up
+     * @param moduleCrit the criteria to match
+     * @param matcher the matcher to use to match criteria
+     * @return an array of matching module revision ids
+     */
",0,0
196,"-	Adrian Sandor 	
+	Adrian Sandor
",0,0
197,"-                                out.print("" ""+attName+""=\""""+attributes.getValue(attName)+""\"""");
+                                out.print("" ""+attName+""=\""""+substitute(ivy, attributes.getValue(attName))+""\"""");
",1,0
198,"-@SuppressWarnings(""serial"")
",0,0
199,"+- FIX: retrieval of mulitple artifacts in different configurations does not work as expected (IVY-188)
",0,0
200,"+      <action issue=""BCEL-110"" type=""fix"">Problem with JAXB if the bcel classloader is used</action>
",0,0
201,"-      for (final PathEntry path : paths) {
-          final ClassFile cf = path.getClassFile(name, suffix);
-
-          if(cf != null) {
-              return cf;
-          }
-      }
+        for (final AbstractPathEntry path : paths) {
+            final ClassFile cf = path.getClassFile(name, suffix);
 
-      return null;
-   }
+            if (cf != null) {
+                return cf;
+            }
+        }
 
+        return null;
+    }
",1,0
202,"-            Method[] ms = jc.getMethods();
-            Method m = null;
-            for (Method element : ms) {
-                if ( (element.getName().equals(o.getMethodName(cpg))) &&
-                     (Type.getReturnType(element.getSignature()).equals(o.getReturnType(cpg))) &&
-                     (objarrayequals(Type.getArgumentTypes(element.getSignature()), o.getArgumentTypes(cpg))) ){
-                    m = element;
-                    break;
-                }
-            }
+            Method m = getMethodRecursive(jc, o);
             if (m == null){
-                constraintViolated(o, ""Referenced method '""+o.getMethodName(cpg)+""' with expected signature '""+o.getSignature(cpg) +""' not found in class '""+jc.getClassName()+""'. The native verifier possibly allows the method to be declared in some superclass or implemented interface, which the Java Virtual Machine Specification, Second Edition does not."");
+                constraintViolated(o, ""Referenced method '""+o.getMethodName(cpg)+""' with expected signature '""+o.getSignature(cpg) +""' not found in class '""+jc.getClassName()+""'."");
",1,0
203,"-        this.num_bootstrap_arguments = num_bootstrap_arguments;
+        this.bootstrap_arguments = new int[num_bootstrap_arguments];
",1,0
204,"-
+[BCEL-177] MethodParameters should read 1 byte not two for parameter count
",0,1
205,"-
",0,0
206,"-        addHandle();
",1,0
207,"+    // tests for BCEL-197
",0,1
208,"-
",0,1
209,"-public class INVOKEDYNAMIC extends NameSignatureInstruction implements ExceptionThrower,
-        StackConsumer, StackProducer {
+public class INVOKEDYNAMIC extends InvokeInstruction {
",1,1
210,"+
+    /**
+     * Override the parent method because our classname is held elsewhere.
+     */
+    public String getClassName( ConstantPoolGen cpg ) {
+        ConstantPool cp = cpg.getConstantPool();
+        ConstantInvokeDynamic cid = (ConstantInvokeDynamic) cp.getConstant(super.getIndex(), Const.CONSTANT_InvokeDynamic);
+        return ((ConstantNameAndType) cp.getConstant(cid.getNameAndTypeIndex())).getName(cp);
+    }
",1,0
211,"+        return null;
+    }
 
-        @Override
-        InputStream getResourceAsStream(final String name) {
-            // Resource specification uses '/' whatever the platform
-            final File file = toFile(name);
-            try {
-                return file.exists() ? new FileInputStream(file) : null;
-            } catch (final IOException e) {
-                return null;
+    /**
+     * @param name
+     *            fully qualified resource name, e.g. java/lang/String.class
+     * @return InputStream supplying the resource, or null if no resource with that name.
+     * @since 6.0
+     */
+    public InputStream getResourceAsStream(final String name) {
+        for (final AbstractPathEntry path : paths) {
+            InputStream is;
+            if ((is = path.getResourceAsStream(name)) != null) {
+                return is;
",1,1
212,"+    // Note that this field is used to store the
+    // bootstrap_method_attr_index of a ConstantInvokeDynamic.
     protected int class_index; // TODO make private (has getter & setter)
+    // This field has the same meaning for all subclasses.
",0,0
213,"-    4/*invokeinterface*/, 5/*invokedynamic*/, 2/*new*/,
+    4/*invokeinterface*/, 4/*invokedynamic*/, 2/*new*/,
",0,0
214,"+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package org.apache.bcel;
+
+import org.apache.bcel.classfile.JavaClass;
+import org.apache.bcel.classfile.Method;
+import org.apache.bcel.generic.ACONST_NULL;
+import org.apache.bcel.generic.ALOAD;
+import org.apache.bcel.generic.ConstantPoolGen;
+import org.apache.bcel.generic.GETSTATIC;
+import org.apache.bcel.generic.INVOKEVIRTUAL;
+import org.apache.bcel.generic.Instruction;
+import org.apache.bcel.generic.InstructionList;
+import org.apache.bcel.generic.LocalVariableGen;
+import org.apache.bcel.generic.MethodGen;
+import org.apache.bcel.generic.Type;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.util.LinkedList;
+import java.util.List;
+
+public class LocalVariableTypeTableTestCase extends AbstractTestCase {
+    public class TestClassLoader extends ClassLoader {
+        public TestClassLoader(ClassLoader parent) {
+            super(parent);
+        }
+
+        public Class<?> findClass(String name, byte[] bytes) {
+            return defineClass(name, bytes, 0, bytes.length);
+        }
+    }
+
+    @Test
+    public void testWithGenericArguement() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {
+        String targetClass = PACKAGE_BASE_NAME + "".data.SimpleClassHasMethodIncludeGenericArgument"";
+        TestClassLoader loader = new TestClassLoader(getClass().getClassLoader());
+        Class cls = loader.findClass(targetClass, getBytesFromClass(targetClass));
+
+        java.lang.reflect.Method method = cls.getDeclaredMethod(""a"", String.class, List.class);
+        method.invoke(null, ""a1"", new LinkedList<String>());
+        method = cls.getDeclaredMethod(""b"", String.class, List.class);
+        method.invoke(null, ""b1"", new LinkedList<String>());
+        method = cls.getDeclaredMethod(""c"", String.class, String.class);
+        method.invoke(null, ""c1"", ""c2"");
+        method = cls.getDeclaredMethod(""d"", List.class, String.class);
+        method.invoke(null, new LinkedList<String>(), ""d2"");
+    }
+
+    private byte[] getBytesFromClass(String className) throws ClassNotFoundException, IOException {
+        JavaClass clazz = getTestClass(className);
+        ConstantPoolGen cp = new ConstantPoolGen(clazz.getConstantPool());
+
+        Method[] methods = clazz.getMethods();
+
+        for (int i = 0; i < methods.length; i++) {
+            Method method = methods[i];
+            if (!method.isNative() && !method.isAbstract())
+                methods[i] = injection(clazz, method, cp, findFirstStringLocalVariableOffset(method));
+        }
+
+        clazz.setConstantPool(cp.getFinalConstantPool());
+
+        return clazz.getBytes();
+    }
+
+    public Method injection(JavaClass clazz, Method method, ConstantPoolGen cp, int firstStringOffset) {
+        MethodGen methodGen = new MethodGen(method, clazz.getClassName(), cp);
+
+        InstructionList instructionList = methodGen.getInstructionList();
+        instructionList.insert(instructionList.getStart(), makeWillBeAddedInstructionList(methodGen, firstStringOffset));
+
+        methodGen.setMaxStack();
+        methodGen.setMaxLocals();
+
+        method = methodGen.getMethod();
+        instructionList.dispose();
+
+        return method;
+    }
+
+    public InstructionList makeWillBeAddedInstructionList(MethodGen methodGen, int firstStringOffset) {
+        if (firstStringOffset == -1)
+            return new InstructionList();
+
+        LocalVariableGen localVariableGen = methodGen.getLocalVariables()[firstStringOffset];
+        Instruction instruction;
+
+        if (localVariableGen != null)
+            instruction = new ALOAD(localVariableGen.getIndex());
+        else
+            instruction = new ACONST_NULL();
+
+        return createPrintln(methodGen.getConstantPool(), instruction);
+    }
+
+    public InstructionList createPrintln(ConstantPoolGen cp, Instruction instruction) {
+        final InstructionList il = new InstructionList();
+
+        final int out = cp.addFieldref(""java.lang.System"", ""out"", ""Ljava/io/PrintStream;"");
+        final int println = cp.addMethodref(""java.io.PrintStream"", ""println"", ""(Ljava/lang/String;)V"");
+        il.append(new GETSTATIC(out));
+        il.append(instruction);
+        il.append(new INVOKEVIRTUAL(println));
+
+        return il;
+    }
+
+    public int findFirstStringLocalVariableOffset(Method method) {
+        Type[] argumentTypes = method.getArgumentTypes();
+        int offset = -1;
+
+        for (int i = 0, count = argumentTypes.length; i < count; i++) {
+            if (Type.STRING.getSignature().equals(argumentTypes[i].getSignature())) {
+                if (method.isStatic())
+                    offset = i;
+                else
+                    offset = i + 1;
+
+                break;
+            }
+        }
+
+        return offset;
+    }
+}
",0,1
215,"- * @author  Bill Pugh
",0,1
216,"-
-    private static void getPathComponents( final String path, final List<String> list ) {
+    private static void getPathComponents(final String path, final List<String> list) {
",0,0
217,"-                    } else if (a instanceof LocalVariableTypeTable) {
-                        LocalVariable[] lv = ((LocalVariableTypeTable) a).getLocalVariableTypeTable();
-                        removeLocalVariables();
-                        for (LocalVariable l : lv) {
-                            InstructionHandle start = il.findHandle(l.getStartPC());
-                            InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());
-                            // Repair malformed handles
-                            if (null == start) {
-                                start = il.getStart();
-                            }
-                            if (null == end) {
-                                end = il.getEnd();
-                            }
-                            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l
-                                    .getIndex(), start, end);
-                        }
",1,0
218,"-            final File file = new File(dir + File.separatorChar + name.replace('/', File.separatorChar));
+            final File file = toFile(name);
",0,0
219,"-     * @return Class this field belongs to.
+     * @param bootstrap_method_attr_index points to a BootstrapMethod. 
+     *
+     * Note that this method is a functional duplicate of setClassIndex
+     * for use by ConstantInvokeDynamic.
      */
-    public String getClass( ConstantPool cp ) {
-        return cp.constantToString(class_index, Constants.CONSTANT_Class);
+    public final void setBootstrapMethodAttrIndex(int bootstrap_method_attr_index) {
+        this.class_index = bootstrap_method_attr_index;
+    }
+
+
+    /**
+     * @return Reference (index) to signature of the field.
+     */
+    public final int getNameAndTypeIndex() {
+        return name_and_type_index;
",1,1
220,"+        map.put(""lstore"", precompile(Constants.LSTORE_0, Constants.LSTORE_3, Constants.LSTORE));
",1,1
221,"-    public ConstantInvokeDynamic(int bootstrap_method_attr_index,
-            int name_and_type_index) {
-        super(Constants.CONSTANT_InvokeDynamic);
-        this.bootstrap_method_attr_index = bootstrap_method_attr_index;
-        this.name_and_type_index = name_and_type_index;
+    public ConstantInvokeDynamic(int bootstrap_method_attr_index, int name_and_type_index) {
+        super(Constants.CONSTANT_InvokeDynamic, bootstrap_method_attr_index, name_and_type_index);
",1,0
222,"+    // helper method
+    private BootstrapMethod(int bootstrap_method_ref, int num_bootstrap_arguments) {
+        this(bootstrap_method_ref, new int[num_bootstrap_arguments]);
+    }
",1,0
223,"+                // read new style stack map: StackMapTable.  The rest of the code
+                // calls this a StackMap for historical reasons.
",0,0
224,"-
-        /** @return modification time of class file.
+        /**
+         * @return modification time of class file.
",0,0
225,"+        this.orig_index = index;
+    }
+
+
+    /**
+     * @param start_pc Range in which the variable
+     * @param length ... is valid
+     * @param name_index Index in constant pool of variable name
+     * @param signature_index Index of variable's signature
+     * @param index Variable is `index'th local variable on the method's frame
+     * @param constant_pool Array of constants
+     * @param orig_index Variable is `index'th local variable on the method's frame prior to any changes
+     */
+    public LocalVariable(final int start_pc, final int length, final int name_index, final int signature_index, final int index,
+            final ConstantPool constant_pool, final int orig_index) {
+        this.start_pc = start_pc;
+        this.length = length;
+        this.name_index = name_index;
+        this.signature_index = signature_index;
+        this.index = index;
+        this.constant_pool = constant_pool;
+        this.orig_index = orig_index;
",1,1
226,"+import org.apache.bcel.Constants;
+
 /**
- * Entry of the bootstrap_methods table.
+ * This class represents a bootstrap method attribute, i.e., the bootstrap
+ * method ref, the number of bootstrap arguments and an array of the
+ * bootstrap arguments.
",1,0
227,"-        this(c.getBootstrapMethodRef(), c.getNumBootstrapArguments(), c.getBootstrapArguments());
+        this(c.getBootstrapMethodRef(), c.getBootstrapArguments());
",1,0
228,"-    public BootstrapMethod() {
+
+    /**
+     * Initialize from another object.
+     */
+    public BootstrapMethod(BootstrapMethod c) {
+        this(c.getBootstrapMethodRef(), c.getNumBootstrapArguments(), c.getBootstrapArguments());
",1,1
229,"-     * A Control Flow Graph.
+     * A Control Flow Graph; with additional JustIce checks
+     * @param  method_gen the method generator instance
",0,0
230,"-        if (opcode == Constants.INVOKESTATIC) {
+        if ((opcode == Constants.INVOKESTATIC) || (opcode == Constants.INVOKEDYNAMIC)) {
",1,1
231,"+    private LocalVariableTable local_variable_table = null;
+    private LocalVariableTypeTable local_variable_type_table = null;
",1,1
232,"-        v.visitNameSignatureInstruction(this);
",1,0
233,"+import org.apache.commons.bcel6.Constants;
",1,0
234,"+            if (local_variable_table != null) {
+                updateLocalVariableTable(local_variable_table);
+            }
",1,1
235,"-        this.constant_pool = constant_pool;
-        this.byte_code_offset = input.readShort();
-
-        int number_of_locals = input.readShort();
-        types_of_locals = new StackMapType[number_of_locals];
-        for (int i = 0; i < number_of_locals; i++) {
-            types_of_locals[i] = new StackMapType(input, constant_pool);
-        }
-
-        int number_of_stack_items = input.readShort();
-        types_of_stack_items = new StackMapType[number_of_stack_items];
-        for (int i = 0; i < number_of_stack_items; i++) {
-            types_of_stack_items[i] = new StackMapType(input, constant_pool);
+        this(input.readByte() & 0xFF, -1, null, null, constant_pool);
+
+        if (frame_type >= Constants.SAME_FRAME && frame_type <= Constants.SAME_FRAME_MAX) {
+            byte_code_offset = frame_type - Constants.SAME_FRAME;
+        } else if (frame_type >= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME && 
+                   frame_type <= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
+            byte_code_offset = frame_type - Constants.SAME_LOCALS_1_STACK_ITEM_FRAME;
+            types_of_stack_items = new StackMapType[1];
+            types_of_stack_items[0] = new StackMapType(input, constant_pool);
+        } else if (frame_type == Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
+            byte_code_offset = input.readShort();
+            types_of_stack_items = new StackMapType[1];
+            types_of_stack_items[0] = new StackMapType(input, constant_pool);
+        } else if (frame_type >= Constants.CHOP_FRAME && frame_type <= Constants.CHOP_FRAME_MAX) {
+            byte_code_offset = input.readShort();
+        } else if (frame_type == Constants.SAME_FRAME_EXTENDED) {
+            byte_code_offset = input.readShort();
+        } else if (frame_type >= Constants.APPEND_FRAME && frame_type <= Constants.APPEND_FRAME_MAX) {
+            byte_code_offset = input.readShort();
+            int number_of_locals = frame_type - 251;
+            types_of_locals = new StackMapType[number_of_locals];
+            for (int i = 0; i < number_of_locals; i++) {
+                types_of_locals[i] = new StackMapType(input, constant_pool);
+            }            
+        } else if (frame_type == Constants.FULL_FRAME) {        
+            byte_code_offset = input.readShort();
+            int number_of_locals = input.readShort();
+            types_of_locals = new StackMapType[number_of_locals];
+            for (int i = 0; i < number_of_locals; i++) {
+                types_of_locals[i] = new StackMapType(input, constant_pool);
+            }
+            int number_of_stack_items = input.readShort();
+            types_of_stack_items = new StackMapType[number_of_stack_items];
+            for (int i = 0; i < number_of_stack_items; i++) {
+                types_of_stack_items[i] = new StackMapType(input, constant_pool);
+            }
+        } else {
+            /* Can't happen */
+            throw new ClassFormatException (""Invalid frame type found while parsing stack map table: "" + frame_type);
",1,0
236,"+      <action issue=""BCEL-181"" type=""fix"" dev=""ggregory"">
+        org.apache.bcel.util.ClassLoaderRepository.loadClass(String) leaks input streams.
+      </action>
",0,1
237,"-    private abstract static class PathEntry {
+    private abstract static class AbstractPathEntry {
+
+        abstract ClassFile getClassFile(String name, String suffix) throws IOException;
 
-        abstract ClassFile getClassFile( String name, String suffix ) throws IOException;
         abstract URL getResource(String name);
+
",0,0
238,"-
-
-    /**
-     * @return deep copy of this attribute
-     */
-    @Override
-    public Attribute copy( ConstantPool constant_pool ) {
-        Annotations c = (Annotations) clone();
-        return c;
-    }
",1,0
239,"- *  limitations under the License. 
+ *  limitations under the License.
",0,0
240,"-        final String[] cmdAttribs = new String[] {""cmd.exe"", ""/C"", ""dir /a /-c "" + path};
+        final String[] cmdAttribs = new String[] {""cmd.exe"", ""/C"", ""dir /a /-c "" + normPath};
",0,1
241,"-     * Constructs a new BOM InputStream that detects a
-     * a {@link ByteOrderMark#UTF_8} and optionally includes it.
-     * @param delegate the InputStream to delegate to
-     * @param include true to include the UTF-8 BOM or
-     * false to exclude it
+     * Constructs a new BOM InputStream that detects a a {@link ByteOrderMark#UTF_8} and optionally includes it.
+     * 
+     * @param delegate
+     *            the InputStream to delegate to
+     * @param include
+     *            true to include the UTF-8 BOM or false to exclude it
",0,0
242,"-  (It was always supposed to...)
+  - It was always supposed to...
+
+- FileSystemUtils.freeSpace/freeSpaceKb [IO-83]
+  - These should now work on AIX and HP-UX
",0,0
243,"-                return doLenientDetection(null, is, ex);
+                return doLenientDetection(null, ex);
",1,0
244,"+        String dfPath = ""df"";
",0,0
245,"-                        listener.handle(sb.toString());
-                        sb.setLength(0);
+                        listener.handle(new String(lineBuf.toByteArray(), cset));
+                        lineBuf.reset(); 
",1,0
246,"+    /**
+     * List files recursively
+     */
+    private static final ListDirectoryWalker LIST_WALKER = new ListDirectoryWalker();
+
",0,0
247,"-        final StringReader reader = new StringReader(lines);
-        FileSystemUtils fsu = new FileSystemUtils() {
-            protected BufferedReader openProcessStream(String[] params) {
-                return new BufferedReader(reader);
-            }
-        };
+        FileSystemUtils fsu = new MockFileSystemUtils(0, lines);
",0,0
248,"-    public void close() throws IOException {        
+    public void close() throws IOException {
",0,0
249,"-                encoding = encoding != null ? encoding.toUpperCase(Locale.US) : null;
+                encoding = encoding != null ? encoding.toUpperCase(Locale.ROOT) : null;
",1,1
250,"-import java.io.InputStreamReader;
 import java.io.IOException;
+import java.io.InputStreamReader;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
",0,0
251,"-        _testAlternateDefaultEncoding(""application/xml"", ""UTF-8-bom"", ""UTF-8"",
-                null, null);
-        _testAlternateDefaultEncoding(""application/xml"", ""no-bom"", ""US-ASCII"",
-                null, ""US-ASCII"");
-        _testAlternateDefaultEncoding(""application/xml"", ""UTF-8-bom"", ""UTF-8"",
-                null, ""UTF-8"");
-        _testAlternateDefaultEncoding(""text/xml"", ""no-bom"", ""US-ASCII"", null,
-                null);
-        _testAlternateDefaultEncoding(""text/xml"", ""no-bom"", ""US-ASCII"", null,
-                ""US-ASCII"");
-        _testAlternateDefaultEncoding(""text/xml"", ""no-bom"", ""US-ASCII"", null,
-                ""UTF-8"");
-
-        _testHttpInvalid(""text/xml;charset=UTF-16BE"", ""UTF-16BE-bom"",
-                ""UTF-16BE"", null);
-        _testHttpInvalid(""text/xml;charset=UTF-16BE"", ""UTF-16BE-bom"",
-                ""UTF-16BE"", ""UTF-16"");
-        _testHttpInvalid(""text/xml;charset=UTF-16BE"", ""UTF-16BE-bom"",
-                ""UTF-16BE"", ""UTF-16BE"");
-        _testHttpInvalid(""text/xml;charset=UTF-16"", ""no-bom"", ""UTF-16BE"",
-                ""UTF-16BE"");
+        _testAlternateDefaultEncoding(""application/xml"", ""UTF-8-bom"", ""UTF-8"", null, null);
+        _testAlternateDefaultEncoding(""application/xml"", ""no-bom"", ""US-ASCII"", null, ""US-ASCII"");
+        _testAlternateDefaultEncoding(""application/xml"", ""UTF-8-bom"", ""UTF-8"", null, ""UTF-8"");
+        _testAlternateDefaultEncoding(""text/xml"", ""no-bom"", ""US-ASCII"", null, null);
+        _testAlternateDefaultEncoding(""text/xml"", ""no-bom"", ""US-ASCII"", null, ""US-ASCII"");
+        _testAlternateDefaultEncoding(""text/xml"", ""no-bom"", ""US-ASCII"", null, ""UTF-8"");
+
+        _testHttpInvalid(""text/xml;charset=UTF-16BE"", ""UTF-16BE-bom"", ""UTF-16BE"", null);
+        _testHttpInvalid(""text/xml;charset=UTF-16BE"", ""UTF-16BE-bom"", ""UTF-16BE"", ""UTF-16"");
+        _testHttpInvalid(""text/xml;charset=UTF-16BE"", ""UTF-16BE-bom"", ""UTF-16BE"", ""UTF-16BE"");
+        _testHttpInvalid(""text/xml;charset=UTF-16"", ""no-bom"", ""UTF-16BE"", ""UTF-16BE"");
",0,0
252,"-        _testHttpValid(""text/xml;charset=UTF-16"", ""UTF-16BE-bom"", ""UTF-16BE"",
-                null);
-        _testHttpValid(""text/xml;charset=UTF-16"", ""UTF-16BE-bom"", ""UTF-16BE"",
-                ""UTF-16"");
-        _testHttpValid(""text/xml;charset=UTF-16"", ""UTF-16BE-bom"", ""UTF-16BE"",
-                ""UTF-16BE"");
+        _testHttpValid(""text/xml;charset=UTF-16"", ""UTF-16BE-bom"", ""UTF-16BE"", null);
+        _testHttpValid(""text/xml;charset=UTF-16"", ""UTF-16BE-bom"", ""UTF-16BE"", ""UTF-16"");
+        _testHttpValid(""text/xml;charset=UTF-16"", ""UTF-16BE-bom"", ""UTF-16BE"", ""UTF-16BE"");
+        _testHttpValid(""text/xml;charset=UTF-32"", ""UTF-32BE-bom"", ""UTF-32BE"", null);
+        _testHttpValid(""text/xml;charset=UTF-32"", ""UTF-32BE-bom"", ""UTF-32BE"", ""UTF-32"");
+        _testHttpValid(""text/xml;charset=UTF-32"", ""UTF-32BE-bom"", ""UTF-32BE"", ""UTF-32BE"");
",0,0
253,"-                    ""Command line '"" + dfPath + ""' did not return numeric data as expected "" +
+                    ""Command line '"" + DF + ""' did not return numeric data as expected "" +
",0,0
254,"+
+        assertEquals(1, FilenameUtils.getPrefixLength(""/:foo""));
+        assertEquals(1, FilenameUtils.getPrefixLength(""/:/""));
+        assertEquals(1, FilenameUtils.getPrefixLength(""/:::::::.txt""));
",0,1
255,"-    }
+
+        assertEquals(9, FilenameUtils.getPrefixLength(""//server/a/b/c.txt""));
+        assertEquals(-1, FilenameUtils.getPrefixLength(""\\\\\\a\\b\\c.txt""));
+        assertEquals(-1, FilenameUtils.getPrefixLength(""///a/b/c.txt""));
+}
",0,1
256,"-            return sizeOfDirectoryAsBigInteger(file);
+            return sizeOfDirectoryBig0(file); // internal method
",1,1
257,"-            fsu.freeSpaceUnix(""/home/users/s"", false, true);
+            fsu.freeSpaceUnix(""/home/users/s"", false, true, -1);
",0,0
258,"-        assertEquals(41411551232L, fsu.freeSpaceWindows(""""));
+        assertEquals(41411551232L, fsu.freeSpaceWindows("""", -1));
",0,1
259,"+    /**
+     * Test for https://issues.apache.org/jira/browse/IO-128
+     */
+    public void testEqualsNormalizedError_IO_128() {
+        try {
+            FilenameUtils.equalsNormalizedOnSystem(""//file.txt"", ""file.txt"");
+            fail(""Invalid normalized first file"");
+        } catch(IllegalArgumentException e) {
+            // expected result
+        }
+        try {
+            FilenameUtils.equalsNormalizedOnSystem(""file.txt"", ""//file.txt"");
+            fail(""Invalid normalized second file"");
+        } catch(IllegalArgumentException e) {
+            // expected result
+        }
+        try {
+            FilenameUtils.equalsNormalizedOnSystem(""//file.txt"", ""//file.txt"");
+            fail(""Invalid normalized both filse"");
+        } catch(IllegalArgumentException e) {
+            // expected result
+        }
+    }
+
",0,0
260,"-    private static ReferenceQueue /* Tracker */ q = new ReferenceQueue();
-
+    static ReferenceQueue /* Tracker */ q = new ReferenceQueue();
",0,0
261,"-    protected void afterRead(int n) {
+    protected synchronized void afterRead(int n) {
",1,0
262,"-        assertEquals(1472504L, fsu.freeSpaceUnix(""/home/users/s"", false));
+        assertEquals(1472504L, fsu.freeSpaceUnix(""/home/users/s"", false, false));
",0,0
263,"+        if (input1 == input2) {
+            return true;
+        }
",1,0
264,"-        return (secondCount < 0) ? firstCount : firstCount + secondCount;
+        return (secondCount < 0) ? (firstCount > 0 ? firstCount : -1) : firstCount + secondCount;
",1,1
265,"-                count = (size - pos) > FIFTY_MB ? FIFTY_MB : (size - pos);
+                count = (size - pos) > FILE_COPY_BUFFER_SIZE ? FILE_COPY_BUFFER_SIZE : (size - pos);
",0,0
266,"+            fbLength = 0;
",1,1
267,"+     * @since Commons IO 2.1
      */
-    public WriterOutputStream(Writer writer, Charset charset, int bufferSize, boolean writeImmediately) {
+    public WriterOutputStream(Writer writer, CharsetDecoder decoder, int bufferSize, boolean writeImmediately) {
         this.writer = writer;
-        decoder = charset.newDecoder();
-        decoder.onMalformedInput(CodingErrorAction.REPLACE);
-        decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);
-        decoder.replaceWith(""?"");
+        this.decoder = decoder;
",0,1
268,"-                        sb.append('\r');
-                        seenCR = false;
+                        seenCR = false; // swallow final CR
+                        listener.handle(sb.toString());
+                        sb.setLength(0);
+                        rePos = pos + i + 1;
",1,1
269,"-            if (parent.exists() == false) {
+            if (parent != null && parent.exists() == false) {
",1,0
270,"+      <action issue=""IO-311"" dev=""sebb"" type=""fix"" due-to=""Robert Muir"">
+        IOUtils.read(InputStream/Reader) ignores the offset parameter
+      </action>        
",0,1
271,"-      <action dev=""ggregory"" type=""add"" issue=""IO-302"" due-to=""jsteuerwald"">
+      <action dev=""ggregory"" type=""add"" issue=""IO-302"" due-to=""jsteuerwald, detinho"">
",0,0
272,"+    
+    /**
+     * Check lower case encoding names are properly handled. Should be successfull
+     * with any system default locale, notably with Turkish language
+     * (-Duser.language=tr JVM parameter), which has specific rules to convert
+     * dotted and dottless i character.
+     */
+    @Test
+    public void testLowerCaseEncoding() throws IOException {
+        checkXmlWriter(TEXT_UNICODE, ""utf-8"");
+        checkXmlWriter(TEXT_LATIN1, ""iso-8859-1"");
+        checkXmlWriter(TEXT_LATIN7, ""iso-8859-7"");
+    }
",0,0
273,"+            IOUtils.closeQuietly(output);
+            IOUtils.closeQuietly(fos);
             IOUtils.closeQuietly(input);
+            IOUtils.closeQuietly(fis);
",1,0
274,"-            fsu.freeSpaceUnix("""", false, true);
+            fsu.freeSpaceUnix("""", false, true, -1);
",0,0
275,"+import java.util.Locale;
",1,0
276,"+    public void testGetFreeSpaceWindows_String_quoted() throws Exception {
+        String lines =
+            "" Volume in drive C is HDD\n"" +
+            "" Volume Serial Number is XXXX-YYYY\n"" +
+            ""\n"" +
+            "" Directory of C:\\Documents and Settings\\Xxxx\n"" +
+            ""\n"" +
+            ""19/08/2005  22:43    <DIR>          .\n"" +
+            ""19/08/2005  22:43    <DIR>          ..\n"" +
+            ""11/08/2005  01:07                81 build.properties\n"" +
+            ""17/08/2005  21:44    <DIR>          Desktop\n"" +
+            ""               7 File(s)         180260 bytes\n"" +
+            ""              10 Dir(s)     41411551232 bytes free"";
+        FileSystemUtils fsu = new MockFileSystemUtils(0, lines, ""dir /-c \""C:\\somedir\"""");
+        assertEquals(41411551232L, fsu.freeSpaceWindows(""\""C:\\somedir\"""", -1));
+    }
+
",0,1
277,"-        return freeSpaceKb(new File(""."").getAbsolutePath()); 
+        return freeSpaceKb(-1); 
+    }
+
+    /**
+     * Returns the disk size of the volume which holds the working directory.
+     * <p>
+     * Identical to:
+     * <pre>
+     * freeSpaceKb(new File(""."").getAbsolutePath())
+     * </pre>
+     * @param timeout The timout amount in milliseconds or no timeout if the value
+     *  is zero or less
+     * @return the amount of free drive space on the drive or volume in kilobytes
+     * @throws IllegalStateException if an error occurred in initialisation
+     * @throws IOException if an error occurs when finding the free space
+     * @since Commons IO 2.0
+     */
+    public static long freeSpaceKb(long timeout) throws IOException {
+        return freeSpaceKb(new File(""."").getAbsolutePath(), timeout); 
",1,1
278,"+ * <p>The file is read using the default charset; this can be overriden if necessary</p>
",0,0
279,"-            <action dev=""rwinston"" type=""fix"" issue=""NET-248"">
+            <action issue=""NET-248"" dev=""rwinston"" type=""fix"">
",0,1
280,"-                csl.cleanUp(); // fetch any outstanding keepalive replies
+                __cslDebug = csl.cleanUp(); // fetch any outstanding keepalive replies
",0,0
281,"-                     new BufferedReader(new InputStreamReader(_input_, getControlEncoding()));
+                     new CRLFLineReader(new InputStreamReader(_input_, getControlEncoding()));
",1,1
282,"+        _hostname_ = null;
",1,0
283,"-                    if ((ch = __read()) < 0)
+                    if ((ch = __read(true)) < 0)
",1,0
284,"-
",0,0
285,"+                case '\n':
+                    if (!__lastWasCR) { // convert LF to CRLF
+                        __client._sendByte('\r');
+                    }
+                    __client._sendByte(ch);
+                    __lastWasCR = false;
+                    break;
",1,0
286,"+import org.apache.commons.net.io.CRLFLineReader;
",1,1
287,"+        _connect(host, port, localAddr, localPort);
+    }
+
+    // helper method to allow code to be shared with connect(String,...) methods
+    private void _connect(InetAddress host, int port, InetAddress localAddr, int localPort)
+        throws SocketException, IOException
+    {
",0,0
288,"-    /** Pattern for PASV mode responses */
-    private static final String __parms = ""\\d{1,3},\\d{1,3},\\d{1,3},\\d{1,3},\\d{1,3},\\d{1,3}"";
-    private static final java.util.regex.Pattern __parms_pat;
+    /** Pattern for PASV mode responses. Groups: (n,n,n,n),(n),(n) */
+    private static final java.util.regex.Pattern __PARMS_PAT;
     static {
-        __parms_pat = java.util.regex.Pattern.compile(__parms);
+        __PARMS_PAT = java.util.regex.Pattern.compile(
+                ""(\\d{1,3},\\d{1,3},\\d{1,3},\\d{1,3}),(\\d{1,3}),(\\d{1,3})"");
",0,0
289,"+            <action issue=""NET-341"" dev=""sebb"" type=""fix"">
+            FTPClient.remoteAppend(String filename) uses STOR instead of APPE
+            </action>
+            <action issue=""NET-339"" dev=""sebb"" type=""fix"">
+            Incorrect parsing of timestamp on Windows CE
+            Fix parsing to allow for new-style DOS listing using 24hr clock rather than AM/PM
+            </action>
",0,0
290,"+    /**
+     * Return whether strict multiline parsing is enabled, as per RFX 959, section 4.2.
+     * @return True if strict, false if lenient
+     */
+	public boolean isStrictMultilineParsing() {
+		return strictMultilineParsing;
+	}
+
+	/**
+	 * Set strict multiline parsing.
+	 * @param strictMultilineParsing
+	 */
+	public void setStrictMultilineParsing(boolean strictMultilineParsing) {
+		this.strictMultilineParsing = strictMultilineParsing;
+	}
",1,0
291,"+        checkShortParse(msg, now, input, true);
",0,1
292,"-    public static final int CODE_408 = 408;
",1,0
293,"-                parser = createOS2FTPEntryParser();
+                parser = new OS2FTPEntryParser(config);
",1,0
294,"-        String ip = getRemoteAddress().getHostAddress();
+        String host = (_hostname_ != null) ? _hostname_ : getRemoteAddress().getHostAddress();
",1,1
295,"+     * Identifier for alternate UNIX parser; same as {@link SYST_UNIX} but leading spaces are
+     * trimmed from file names. This is to maintain backwards compatibility with
+     * the original behaviour of the parser which ignored multiple spaces between the date
+     * and the start of the file name.
+     */
+    public static final String SYST_UNIX_TRIM_LEADING  = ""UNIX_LTRIM"";
+
+    /**
",1,1
296,"-        mode = buffer.toString().toLowerCase();
+        mode = buffer.toString().toLowerCase(java.util.Locale.ENGLISH);
",1,0
297,"-        this(config, true); // retain original behaviour (for now)
+        this(config, false);
",1,0
298,"-        return __retrieveHeader(header, Integer.toString(articleNumber));
+        return __retrieveHeader(header, Long.toString(articleNumber));
",1,0
299,"-            <action dev=""rwinston"" type=""update"" issue=""NET-261"">
+            <action issue=""NET-261"" dev=""rwinston"" type=""update"">
",0,1
300,"+            <action issue=""NET-597"" type=""fix"" dev=""sebb"" due-to=""Hiroki Taniura"">
+            FTP fails to parse listings for Solaris 10 FTPd in Japanese
+            </action>
",0,1
301,"+            <action issue=""NET-602"" type=""fix"" dev=""sebb"" due-to=""Ross Braithwaite"">
+            Failure to parse times from SYST_L8 systems that report as ""WINDOWS Type: L8""
+            </action>
",0,0
302,"+            <action issue=""NET-581"" type=""fix"" dev=""sebb"">
+            SimpleSMTPHeader fails to supply the required Date: header
+            </action>
",0,1
303,"-		FTPFile f = getParser().parseFTPEntry(""-rw-r--r--   1 root     root       111325 Feb 25 12:00 123 456 abc.csv"");
+		FTPFile f = getParser().parseFTPEntry(""-rw-rw-rw-   1 user group 5840 Mar 19 09:34 123 456 abc.csv"");
 		assertEquals(f.getName(), ""123 456 abc.csv"");
+		assertEquals(f.getSize(), 5840);
+		assertEquals(f.getUser(), ""user"");
+		assertEquals(f.getGroup(), ""group"");
",0,1
304,"-            lastNum = Integer.parseInt(last);
-            firstNum = Integer.parseInt(first);
+            lastNum = Long.valueOf(last);
+            firstNum = Long.valueOf(first);
",1,0
305,"+     * Some servers return an ""UNKNOWN Type: L8"" message
+     * in response to the SYST command. We set these to be a Unix-type system.
+     * This may happen if the ftpd in question was compiled without system
+     * information.
+     */
+    public static final String SYST_L8 = ""Type: L8"";
+    
+    /**
",1,1
306,"-            int end;
-            if (param.endsWith(""\"""")) {
-                end = param.length()-1;
-            } else { // perhaps there's a trailing comment
-                end=param.lastIndexOf(""\"" ""); // find start of comment (assume it does not contain "")
+            StringBuilder sb = new StringBuilder();
+            boolean quoteSeen = false;
+            // start after initial quote
+            for(int i=1; i < param.length(); i++) {
+                char ch = param.charAt(i);
+                if (ch=='""') {
+                    if (quoteSeen) {
+                        sb.append(ch);
+                        quoteSeen=false;
+                    } else {
+                        // don't output yet, in case doubled
+                        quoteSeen=true;
+                    }
+                } else {
+                    if (quoteSeen) { // found lone trailing quote within string
+                        return sb.toString();
+                    }
+                    sb.append(ch); // just another character
+                }
             }
-            if (end != -1) { // It was a match
-                return param.substring(1, end).replace(""\""\"""", ""\"""");            
+            if (quoteSeen) { // found lone trailing quote at end of string
+                return sb.toString();
",1,0
307,"+            output.close(); // ensure the file is fully written
+            socket.close(); // done writing the file
+
+            // Get the transfer response
+            return completePendingCommand();
",1,0
308,"-         *   MMMM [d]d
+         *   MMM [d]d
          *   [d]d MMM
+         *   N.B. use non-space for MMM to allow for languages such as German which use
+         *   diacritics (e.g. umlaut) in some abbreviations.
         */
-        + ""((?:\\d+[-/]\\d+[-/]\\d+)|(?:[a-zA-Z]{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+[a-zA-Z]{3}))\\s+""
+        + ""((?:\\d+[-/]\\d+[-/]\\d+)|(?:\\S{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+\\S{3}))\\s+""
",1,0
309,"-            <action dev=""rwinston"" type=""fix"" issue=""NET-279"">
+            <action issue=""NET-279"" dev=""rwinston"" type=""fix"">
",0,1
310,"+            <action issue=""NET-624"" type=""update"" dev=""sebb"" due-to=""Makoto Sakaguchi"">
+            SubnetInfo#getCidrSignature - improve functions
+            </action>
",0,0
311,"+            <action issue=""NET-276"" dev=""sebb"" type=""fix"">
+            NNTPClient has problems with group listings for large groups.
+            </action>
",0,0
312,"+        checkShortParse(msg, now, input, false);
+    }
+
+    /*
+     * Check how short date is interpreted at a given time
+     */
+    private void checkShortParse(String msg, Calendar now, Calendar input, boolean lenient) throws ParseException {
         FTPTimestampParserImpl parser = new FTPTimestampParserImpl();
+        parser.setLenientFutureDates(true);
",0,1
313,"-            int diff = address - low();
-            return (diff >= 0 && (diff <= (high() - low())));
+            long addLong = address & UNSIGNED_INT_MASK;
+            long lowLong = low() & UNSIGNED_INT_MASK;
+            long highLong = high() & UNSIGNED_INT_MASK;
+            return addLong >= lowLong && addLong <= highLong;
",1,1
314,"-        return doCommand (IMAPCommand.LIST, quoteString(refName) + "" "" + quoteString(mailboxName));
+        return doCommand (IMAPCommand.LIST, quoteMailboxName(refName) + "" "" + quoteMailboxName(mailboxName));
",1,1
315,"-        + ""\\s+"" // separator
+        + ""\\s"" // separator
",1,0
316,"+     * <p>
+     * <b>N.B.</b> the method calls
+     *  {@link #setSocketFactory(javax.net.SocketFactory)} and
+     *  {@link #setServerSocketFactory(javax.net.ServerSocketFactory)}
+     *  
",0,0
317,"+    public static final int CODE_480 = 480;
",1,0
318,"-            if (recentDateFormat != null) {
-                pp = new ParsePosition(0);
-                int year = now.get(Calendar.YEAR);
-                String timeStampStrPlusYear = timestampStr + "" "" + year;
-                SimpleDateFormat hackFormatter = new SimpleDateFormat(recentDateFormat.toPattern() + "" yyyy"",
-                        recentDateFormat.getDateFormatSymbols());
-                hackFormatter.setLenient(false);
-                hackFormatter.setTimeZone(recentDateFormat.getTimeZone());
-                parsed = hackFormatter.parse(timeStampStrPlusYear, pp);
-            }
-            if (parsed != null && pp.getIndex() == timestampStr.length() + 5) {
+            String year = Integer.toString(now.get(Calendar.YEAR));
+            String timeStampStrPlusYear = timestampStr + "" "" + year;
+            SimpleDateFormat hackFormatter = new SimpleDateFormat(recentDateFormat.toPattern() + "" yyyy"",
+                    recentDateFormat.getDateFormatSymbols());
+            hackFormatter.setLenient(false);
+            hackFormatter.setTimeZone(recentDateFormat.getTimeZone());
+            ParsePosition pp = new ParsePosition(0);
+            parsed = hackFormatter.parse(timeStampStrPlusYear, pp);
+            // Check if we parsed the full string, if so it must have been a short date originally
+            if (parsed != null && pp.getIndex() == timeStampStrPlusYear.length()) {
                 working.setTime(parsed);
-            }
-            else {
-                pp = new ParsePosition(0);
-                parsed = defaultDateFormat.parse(timestampStr, pp);
-                // note, length checks are mandatory for us since
-                // SimpleDateFormat methods will succeed if less than
-                // full string is matched.  They will also accept,
-                // despite ""leniency"" setting, a two-digit number as
-                // a valid year (e.g. 22:04 will parse as 22 A.D.)
-                // so could mistakenly confuse an hour with a year,
-                // if we don't insist on full length parsing.
-                if (parsed != null && pp.getIndex() == timestampStr.length()) {
-                    working.setTime(parsed);
-                } else {
-                    throw new ParseException(
-                            ""Timestamp could not be parsed with older or recent DateFormat"",
-                            pp.getErrorIndex());
+                if (working.after(now)) { // must have been last year instead
+                    working.add(Calendar.YEAR, -1);
                 }
+                return working;
",1,0
319,"+
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-simple</artifactId>
+      <version>${slf4j.version}</version>
+      <scope>test</scope>
+    </dependency>
",0,0
320,"-  private static void addGroupType(String t, Tokenizer st, Repetition r, GroupBuilder<?> builder) {
+  private static void addGroupType(Tokenizer st, Repetition r, GroupBuilder<?> builder) {
     GroupBuilder<?> childBuilder = builder.group(r);
+    String t;
",1,0
321,"-    w.writeDataPage(8, 4, BytesInput.from(BYTES4), STATS2, BIT_PACKED, BIT_PACKED, PLAIN);
+    w.writeDataPage(8, 4, BytesInput.from(BYTES4), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);
",0,0
322,"+  private int pageSize = 1024;
+  private int initialSize = 1024;
+  private Configuration conf;
+
+  @Before
+  public void initConfiguration() {
+    this.conf = new Configuration();
+  }
+
",0,0
323,"-  private void addRowGroup(ParquetMetadata parquetMetadata, List<RowGroup> rowGroups, BlockMetaData block) {
+  private static void addRowGroup(ParquetMetadata parquetMetadata, List<RowGroup> rowGroups, BlockMetaData block) {
",1,1
324,"-            convertField(""array"", schema.getElementType(), Type.Repetition.REPEATED));
+            convertField(""array"", schema.getElementType(), REPEATED));
",1,1
325,"+          <systemPropertyVariables>
+            <!-- Configure Parquet logging during tests
+                 See http://www.slf4j.org/api/org/slf4j/impl/SimpleLogger.html
+                 -->
+            <org.slf4j.simpleLogger.defaultLogLevel>info</org.slf4j.simpleLogger.defaultLogLevel>
+            <org.slf4j.simpleLogger.showDateTime>true</org.slf4j.simpleLogger.showDateTime>
+            <org.slf4j.simpleLogger.dateTimeFormat>YYYY-MM-dd HH:mm:ss</org.slf4j.simpleLogger.dateTimeFormat>
+            <org.slf4j.simpleLogger.showThreadName>false</org.slf4j.simpleLogger.showThreadName>
+            <org.slf4j.simpleLogger.showShortLogName>true</org.slf4j.simpleLogger.showShortLogName>
+          </systemPropertyVariables>
",0,1
326,"-    private final FSDataInputStream f;
+    private final SeekableInputStream f;
",1,0
327,"-        stats.setMinMaxFromBytes(statistics.min.array(), statistics.max.array());
+        statsBuilder.withMin(statistics.min.array());
+        statsBuilder.withMax(statistics.max.array());
+      }
+      if (statistics.isSetNull_count()) {
+        statsBuilder.withNumNulls(statistics.null_count);
       }
-      stats.setNumNulls(statistics.null_count);
     }
-    return stats;
+    return statsBuilder.build();
",1,1
328,"+   * @deprecated will be removed in 2.0.0. Use {@link #getBuilder(PrimitiveType)} instead.
    */
+  @Deprecated
",0,0
329,"-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.text.MessageFormat;
-import java.util.Date;
-import java.util.logging.Formatter;
-import java.util.logging.Handler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import java.util.logging.Level;
-import java.util.logging.LogRecord;
-import java.util.logging.Logger;
-import java.util.logging.StreamHandler;
",1,0
330,"-        LOG.info(""Ignoring statistics because this file was created prior to ""
+        warnOnce(""Ignoring statistics because this file was created prior to ""
",0,0
331,"- ./parquet-benchmarks/run.sh -wi 5 -i 5 -f 3 -bm all
+./parquet-benchmarks/run.sh -wi 5 -i 5 -f 3 -bm all
",0,0
332,"+import org.apache.parquet.schema.Types;
",0,1
333,"-      assertEquals(encoding, c.getEncoding(c.getEncoding(encoding)));
+      assertEquals(encoding, ParquetMetadataConverter.getEncoding(ParquetMetadataConverter.getEncoding(encoding)));
",0,0
334,"-    assertEquals(new SemanticVersion(1, 8, 0), SemanticVersion.parse(""1.8.0rc3""));
-    assertEquals(new SemanticVersion(1, 8, 0), SemanticVersion.parse(""1.8.0rc3-SNAPSHOT""));
-    assertEquals(new SemanticVersion(1, 8, 0), SemanticVersion.parse(""1.8.0-SNAPSHOT""));
+    assertEquals(new SemanticVersion(1, 8, 0, true), SemanticVersion.parse(""1.8.0rc3""));
+    assertEquals(new SemanticVersion(1, 8, 0, true), SemanticVersion.parse(""1.8.0rc3-SNAPSHOT""));
+    assertEquals(new SemanticVersion(1, 8, 0, true), SemanticVersion.parse(""1.8.0-SNAPSHOT""));
",0,0
335,"-    w.writeDataPage(7, 4, BytesInput.from(BYTES3), STATS1, BIT_PACKED, BIT_PACKED, PLAIN);
+    w.writeDataPage(7, 4, BytesInput.from(BYTES3), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);
",0,0
336,"+
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-simple</artifactId>
+      <version>${slf4j.version}</version>
+      <scope>test</scope>
+    </dependency>
",0,0
337,"-  private static final Map<Class<?>, Set<FullTypeDescriptor>> classToParquetType = new HashMap<Class<?>, Set<FullTypeDescriptor>>();
-  private static final Map<FullTypeDescriptor, Set<Class<?>>> parquetTypeToClass = new HashMap<FullTypeDescriptor, Set<Class<?>>>();
+  private static final Map<Class<?>, Set<PrimitiveTypeName>> classToParquetType = new HashMap<Class<?>, Set<PrimitiveTypeName>>();
+  private static final Map<PrimitiveTypeName, Set<Class<?>>> parquetTypeToClass = new HashMap<PrimitiveTypeName, Set<Class<?>>>();
",1,0
338,"+import org.apache.parquet.hadoop.metadata.ColumnPath;
 import org.apache.parquet.schema.MessageType;
-import org.apache.parquet.schema.OriginalType;
",1,1
339,"+  Schema convert(GroupType parquetSchema) {
+    return convertFields(parquetSchema.getName(), parquetSchema.getFields());
+  }
+
",1,1
340,"-      int blockSize,
+      int rowGroupSize,
",0,1
341,"-    ParquetMetadata metadataFooter = mergeFooters(outputPath, footers);
",1,0
342,"- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
",0,0
343,"-        ColumnChunkPageWriteStore store = new ColumnChunkPageWriteStore(f.getCompressor(codec, pageSize ), schema , initialSize);
+        ColumnChunkPageWriteStore store = new ColumnChunkPageWriteStore(compressor(GZIP), schema , initialSize);
",0,1
344,"-    } catch (VersionParseException e) {
-      // couldn't parse the created_by field, log what went wrong, don't trust the stats,
-      // but don't make this fatal.
+    } catch (VersionParser.VersionParseException e) {
",1,0
345,"-   * @param originalType the original type according to the schema
    */
-  public static <T extends Comparable<T>> void assertTypeValid(Column<T> foundColumn, PrimitiveTypeName primitiveType, OriginalType originalType) {
+  public static <T extends Comparable<T>> void assertTypeValid(Column<T> foundColumn, PrimitiveTypeName primitiveType) {
",1,0
346,"-  static {
-    // add a default handler in case there is none
-    Logger logger = Logger.getLogger(Log.class.getPackage().getName());
-    Handler[] handlers = logger.getHandlers();
-    if (handlers == null || handlers.length == 0) {
-      logger.setUseParentHandlers(false);
-      StreamHandler handler = new StreamHandler(System.out, new Formatter() {
-        Date dat = new Date();
-        private final static String format = ""{0,date} {0,time}"";
-        private MessageFormat formatter = new MessageFormat(format);
-
-        private Object args[] = new Object[1];
-
-        /**
-         * Format the given LogRecord.
-         * @param record the log record to be formatted.
-         * @return a formatted log record
-         */
-        public synchronized String format(LogRecord record) {
-          StringBuffer sb = new StringBuffer();
-          // Minimize memory allocations here.
-          dat.setTime(record.getMillis());
-          args[0] = dat;
-          formatter.format(args, sb, null);
-          sb.append("" "");
-          sb.append(record.getLevel().getLocalizedName());
-          sb.append("": "");
-          sb.append(record.getLoggerName());
-
-          sb.append("": "");
-          sb.append(formatMessage(record));
-          sb.append(""\n"");
-          if (record.getThrown() != null) {
-            try {
-              StringWriter sw = new StringWriter();
-              PrintWriter pw = new PrintWriter(sw);
-              record.getThrown().printStackTrace(pw);
-              pw.close();
-              sb.append(sw.toString());
-            } catch (Exception ex) {
-            }
-          }
-          return sb.toString();
-        }
-      });
-      handler.setLevel(LEVEL);
-      logger.addHandler(handler);
-    }
-    logger.setLevel(LEVEL);
-  }
-
",1,0
347,"+
+    // udpDropMissingColumn drops null column.
+    assertTrue(canDrop(udpDropMissingColumn, Arrays.asList(
+        getIntColumnMeta(seven, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    assertTrue(canDrop(udpDropMissingColumn, Arrays.asList(
+        getIntColumnMeta(eight, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    assertTrue(canDrop(udpDropMissingColumn, Arrays.asList(
+        getIntColumnMeta(neither, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    // invUdpDropMissingColumn (i.e., not(udpDropMissingColumn)) keeps null column.
+    assertFalse(canDrop(invUdpDropMissingColumn, Arrays.asList(
+        getIntColumnMeta(seven, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    assertFalse(canDrop(invUdpDropMissingColumn, Arrays.asList(
+        getIntColumnMeta(eight, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    assertFalse(canDrop(invUdpDropMissingColumn, Arrays.asList(
+        getIntColumnMeta(neither, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    // udpKeepMissingColumn keeps null column.
+    assertFalse(canDrop(udpKeepMissingColumn, Arrays.asList(
+        getIntColumnMeta(seven, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    assertFalse(canDrop(udpKeepMissingColumn, Arrays.asList(
+        getIntColumnMeta(eight, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    assertFalse(canDrop(udpKeepMissingColumn, Arrays.asList(
+        getIntColumnMeta(neither, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    // invUdpKeepMissingColumn (i.e., not(udpKeepMissingColumn)) drops null column.
+    assertTrue(canDrop(invUdpKeepMissingColumn, Arrays.asList(
+        getIntColumnMeta(seven, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    assertTrue(canDrop(invUdpKeepMissingColumn, Arrays.asList(
+        getIntColumnMeta(eight, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
+
+    assertTrue(canDrop(invUdpKeepMissingColumn, Arrays.asList(
+        getIntColumnMeta(neither, 177L),
+        getDoubleColumnMeta(doubleStats, 177L))));
",0,1
348,"-    List<FileStatus> statuses = Arrays.asList(fs.listStatus(file));
+    List<FileStatus> statuses = Arrays.asList(fs.listStatus(file, new PathFilter() {
+      @Override
+      public boolean accept(Path p) {
+        return !p.getName().startsWith(""_"") && !p.getName().startsWith(""."");
+      }
+    }));
",1,1
349,"-            .accept(new ThriftSchemaConvertVisitor(FieldProjectionFilter.ALL_COLUMNS, false), childState);
+            .accept(new ThriftSchemaConvertVisitor(FieldProjectionFilter.ALL_COLUMNS, false, keepOneOfEachUnion), childState);
",1,1
350,"-  static FileMetaData filterFileMetaData(FileMetaData metaData, OffsetMetadataFilter filter) {
+  static FileMetaData filterFileMetaDataByMidpoint(FileMetaData metaData, RangeMetadataFilter filter) {
",0,0
351,"-  public static final MetadataFilter range(long startOffset, long endOffset) {
+  public static MetadataFilter range(long startOffset, long endOffset) {
",1,1
352,"+import static org.apache.parquet.schema.Type.Repetition.REPEATED;
",1,1
353,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
354,"+        Connection conn = null;
",1,0
355,"-            conn.close();
",1,0
356,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
357,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
358,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
359,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
360,"+        Connection conn = null;
",1,0
361,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
362,"-            conn.close();
",1,0
363,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
364,"-            
-            // Close connection
-            conn.close();
",1,0
365,"+        Connection conn = null;
",1,0
366,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
367,"+        Connection conn = null;
",1,0
368,"-            conn.close();
",1,0
369,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
370,"+        Connection conn = null;
",1,0
371,"+        Connection conn = null;
",1,0
372,"-            conn.close();
",1,0
373,"-
+        Connection conn = null;
+        
",1,0
374,"-
-            // Close connection
-            conn.close();
",1,0
375,"-            conn.close();
",1,0
376,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
377,"-            conn.close();
",1,0
378,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
379,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
380,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
381,"+        Connection conn = null;
",1,0
382,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
383,"-
-            // Close connection
-            conn.close();
",1,0
384,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
385,"+        Connection conn = null;
",1,0
386,"-            conn.close();
",1,0
387,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
388,"+        finally
+        {
+            try { conn.close(); } catch (Exception e) {}
+        }
",1,0
389,"-            conn.close();
",1,0
390,"-            Connection conn = m_ds.getConnection();
+            conn = m_ds.getConnection();
",1,0
391,"-            conn.close();
",1,0
392,"+        Connection conn = null;
",1,0
393,"-            val |= 0xff << bits;
             val++;
+            val |= 0xffl << bits;
",1,1
394,"-    <release version=""1.1"" date=""as in SVN"" description=""Release 1.1"">
+    <release version=""1.2"" date=""as in SVN"" description=""Release 1.2"">
+      <action issue=""COMPRESS-119"" type=""fix"" date=""2010-10-26"">
+        TarArchiveOutputStream#finish now writes all buffered data ot the stream
+      </action> 
+    </release>
+    <release version=""1.1"" date=""2010-08-13"" description=""Release 1.1"">
",0,0
395,"-
 import org.apache.commons.compress.AbstractTestCase;
-import org.apache.commons.compress.archivers.ArchiveEntry;
",0,0
396,"+        if (currentEntryInputStream == null) {
+            throw new IllegalStateException(""No current 7z entry"");
+        }
",1,0
397,"+    private final int blockSize;
+
+    private long nextArtificalDeviceAndInode = 1;
+
     /**
-     * Construct the cpio output stream with a specified format
+     * Construct the cpio output stream with a specified format and a
+     * blocksize of {@link CpioConstants.BLOCK_SIZE BLOCK_SIZE}.
",1,0
398,"-            putShort(INITIAL_VERSION, buf, LFH_VERSION_NEEDED_OFFSET);
+            putShort(versionNeededToExtractMethod(zipMethod), buf, LFH_VERSION_NEEDED_OFFSET);
",1,0
399,"+        //make sure we don't oom on detect
+        assertEquals(CompressorStreamFactory.Z, detect(""COMPRESS-386""));
+        assertEquals(CompressorStreamFactory.LZMA, detect(""COMPRESS-382""));
+
",0,0
400,"-     * given data.
+     * given data, throwing an exception if the data cannot be parsed.
",0,0
401,"-     * field are optional and only present if their corresponding
+     * field are optional and must only be present if their corresponding
",0,0
402,"-        readBytesOfEntry = offsetInBuffer = bytesReadFromStream =
-            lengthOfLastRead = 0;
+        readBytesOfEntry = bytesReadFromStream = 0L;
+        offsetInBuffer = lengthOfLastRead = 0;
",1,1
403,"-        than GNU tar uses itself.
+        than GNU tar uses itself.  This seems to be the case fpr
+        archives created by star.
",0,0
404,"+      <action type=""fix"" date=""2014-03-28"" issue=""COMPRESS-270"">
+        The snappy, ar and tar inputstreams might fail to read from a
+        non-buffered stream in certain cases.
+      </action>
",0,1
405,"-        return new ZipShort(data.length);
+        return new ZipShort(data != null ? data.length : 0);
",1,1
406,"+    /**
+     * Writes magic bytes like BZ on the first position of the stream
+     * and bytes indiciating the file-format, which is 
+     * huffmanised, followed by a digit indicating blockSize100k.
+     * @throws IOException if the magic bytes could not been written
+     */
     private void init() throws IOException {
-        // write magic: done by caller who created this stream
-        // this.out.write('B');
-        // this.out.write('Z');
+        bsPutUByte('B');
+        bsPutUByte('Z');
",1,0
407,"-    private final ZipEncoding encoding;
+    private final ZipEncoding zipEncoding;
+
+    // the provided encoding (for unit tests)
+    final String encoding;
",1,0
408,"-                throw new ZipException(""data starting at "" + start
-                    + "" is in unknown format"");
+                throw new ZipException(""bad extra field starting at ""
+                                       + start + "".  Block length of ""
+                                       + length + "" bytes exceeds remaining""
+                                       + "" data of ""
+                                       + (data.length - start - WORD)
+                                       + "" bytes."");
",0,1
409,"+
+    /**
+     * @see ""https://issues.apache.org/jira/browse/COMPRESS-348""
+     */
+    @Test
+    public void readEntriesOfSize0() throws IOException {
+        final SevenZFile sevenZFile = new SevenZFile(getFile(""COMPRESS-348.7z""));
+        try {
+            int entries = 0;
+            SevenZArchiveEntry entry = sevenZFile.getNextEntry();
+            while (entry != null) {
+                entries++;
+                int b = sevenZFile.read();
+                if (""2.txt"".equals(entry.getName()) || ""5.txt"".equals(entry.getName())) {
+                    assertEquals(-1, b);
+                } else {
+                    assertNotEquals(-1, b);
+                }
+                entry = sevenZFile.getNextEntry();
+            }
+            assertEquals(5, entries);
+        } finally {
+            sevenZFile.close();
+        }
+    }
",0,1
410,"+
+    private static long skipBytesFully(DataInput input, long bytesToSkip) throws IOException {
+        if (bytesToSkip < 1) {
+            return 0;
+        }
+        long skipped = 0;
+        while (bytesToSkip > Integer.MAX_VALUE) {
+            long skippedNow = skipBytesFully(input, Integer.MAX_VALUE);
+            if (skippedNow == 0) {
+                return skipped;
+            }
+            skipped += skippedNow;
+            bytesToSkip -= skippedNow;
+        }
+        while (bytesToSkip > 0) {
+            int skippedNow = input.skipBytes((int) bytesToSkip);
+            if (skippedNow == 0) {
+                return skipped;
+            }
+            skipped += skippedNow;
+            bytesToSkip -= skippedNow;
+        }
+        return skipped;
+    }
",1,1
411,"+      <action issue=""COMPRESS-252"" type=""fix"" date=""2012-12-20"">
+        SevenZOutputFile would create invalid archives if more than
+        six empty files or directories were included.
+      </action>
",0,1
412,"+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.commons.compress.compressors.bzip2;
+
+import static org.junit.Assert.assertArrayEquals;
+
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
+import java.util.Arrays;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * Testcase porting a test from Python's testsuite.
+ * @see ""https://issues.apache.org/jira/browse/COMPRESS-253""
+ */
+public class PythonTruncatedBzip2Test {
+
+    private static String TEXT = ""root:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:\ndaemon:x:2:2:daemon:/sbin:\nadm:x:3:4:adm:/var/adm:\nlp:x:4:7:lp:/var/spool/lpd:\nsync:x:5:0:sync:/sbin:/bin/sync\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nhalt:x:7:0:halt:/sbin:/sbin/halt\nmail:x:8:12:mail:/var/spool/mail:\nnews:x:9:13:news:/var/spool/news:\nuucp:x:10:14:uucp:/var/spool/uucp:\noperator:x:11:0:operator:/root:\ngames:x:12:100:games:/usr/games:\ngopher:x:13:30:gopher:/usr/lib/gopher-data:\nftp:x:14:50:FTP User:/var/ftp:/bin/bash\nnobody:x:65534:65534:Nobody:/home:\npostfix:x:100:101:postfix:/var/spool/postfix:\nniemeyer:x:500:500::/home/niemeyer:/bin/bash\npostgres:x:101:102:PostgreSQL Server:/var/lib/pgsql:/bin/bash\nmysql:x:102:103:MySQL server:/var/lib/mysql:/bin/bash\nwww:x:103:104::/var/www:/bin/false\n"";
+
+    private static byte[] DATA;
+    private static byte[] TRUNCATED_DATA;
+    private ReadableByteChannel bz2Channel;
+
+    @BeforeClass
+    public static void initializeTestData() throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        BZip2CompressorOutputStream bz2out = new BZip2CompressorOutputStream(out);
+        bz2out.write(TEXT.getBytes(), 0, TEXT.getBytes().length);
+        bz2out.close();
+        DATA = out.toByteArray();
+
+        // Drop the eos_magic field (6 bytes) and CRC (4 bytes).
+        TRUNCATED_DATA = Arrays.copyOfRange(DATA, 0, DATA.length - 10);
+    }
+
+    @Before
+    public void initializeChannel() throws IOException {
+        InputStream source = new ByteArrayInputStream(TRUNCATED_DATA);
+        this.bz2Channel = makeBZ2C(source);
+    }
+
+    @After
+    public void closeChannel() throws IOException {
+        bz2Channel.close();
+        bz2Channel = null;
+    }
+
+    @Test(expected = IOException.class)
+    public void testTruncatedData() throws IOException {
+        //with BZ2File(self.filename) as f:
+        //    self.assertRaises(EOFError, f.read)
+        System.out.println(""Attempt to read the whole thing in, should throw ..."");
+        ByteBuffer buffer = ByteBuffer.allocate(8192);
+        bz2Channel.read(buffer);
+    }
+
+    @Test
+    public void testPartialReadTruncatedData() throws IOException {
+        //with BZ2File(self.filename) as f:
+        //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)
+        //    self.assertRaises(EOFError, f.read, 1)
+
+        final int length = TEXT.length();
+        ByteBuffer buffer = ByteBuffer.allocate(length);
+        bz2Channel.read(buffer);
+
+        assertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length),
+                buffer.array());
+
+        // subsequent read should throw
+        buffer = ByteBuffer.allocate(1);
+        try {
+            bz2Channel.read(buffer);
+            Assert.fail(""The read should have thrown."");
+        } catch (IOException e) {
+            // pass
+        }
+    }
+
+    private static ReadableByteChannel makeBZ2C(InputStream source) throws IOException {
+        BufferedInputStream bin = new BufferedInputStream(source);
+        BZip2CompressorInputStream bZin = new BZip2CompressorInputStream(bin, true);
+
+        return Channels.newChannel(bZin);
+    }
+}
",0,1
413,"-        final ZipLong zl = new ZipLong(new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF});
+         ZipLong zl = new ZipLong(new byte[] {(byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF});
         assertEquals(0x00000000FFFFFFFFl, zl.getValue());
+        assertEquals(-1,zl.getIntValue());
+
+        zl = new ZipLong(0xFFFF_FFFFL);
+        assertEquals(0x00000000FFFFFFFFl, zl.getValue());
+        zl = new ZipLong(0xFFFF_FFFF);
+        assertEquals(0xFFFF_FFFF_FFFF_FFFFL, zl.getValue());
+
",0,0
414,"+package org.apache.commons.compress.archivers.cpio;
+
+import java.io.FileInputStream;
+
+import org.apache.commons.compress.AbstractTestCase;
+
+public class CpioArchiveInputStreamTest extends AbstractTestCase {
+
+    public void testCpioUnarchive() throws Exception {
+        StringBuffer expected = new StringBuffer();
+        expected.append(""./test1.xml<?xml version=\""1.0\""?>\n"");
+        expected.append(""<empty/>./test2.xml<?xml version=\""1.0\""?>\n"");
+        expected.append(""<empty/>\n"");
+        
+
+        CpioArchiveInputStream in = 
+                new CpioArchiveInputStream(new FileInputStream(getFile(""bla.cpio"")));
+        CpioArchiveEntry entry= null;
+        
+        StringBuffer result = new StringBuffer();
+        while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {
+            result.append(entry.getName());
+            int tmp;
+            while ((tmp = in.read()) != -1) {
+                result.append((char) tmp);
+             }
+         }
+         in.close();
+         assertEquals(result.toString(), expected.toString());
+    }    
+}
",0,1
415,"-            throw new IOException(""Offset is larger than block size"");
+            throw new IOException(""Offset "" + off + "" is larger than block size "" + blockSize);
",0,0
416,"+      <action issue=""COMPRESS-421"" type=""fix"" date=""2017-10-06""
+              due-to=""Roel Spilker"">
+        When reading tar headers with name fields containing embedded
+        NULs, the name will now be terminated at the first NUL byte.
+      </action>
",0,1
417,"+import org.apache.commons.compress.utils.IOUtils;
",0,1
418,"-     * <p>
-     * Although BZip2 headers are marked with the magic <tt>""Bz""</tt> this
-     * constructor expects the next byte in the stream to be the first one after
-     * the magic. Thus callers have to skip the first two bytes. Otherwise this
-     * constructor will throw an exception.
-     * </p>
-     * 
",0,0
419,"+
+    public ZCompressorInputStream(final InputStream inputStream) throws IOException {
+        this(inputStream, -1);
+    }
",1,0
420,"-    public int read(byte[] b, int off, int len) throws IOException {
-        final int ret = this.input.read(b, off, len);
+    public int read(byte[] b, final int off, final int len) throws IOException {
+        int toRead = len;
+        if (currentEntry != null) {
+            final long entryEnd = entryOffset + currentEntry.getLength();
+            if (len > 0 && entryEnd > offset) {
+                toRead = (int) Math.min(len, entryEnd - offset);
+            } else {
+                return -1;
+            }
+        }
+        final int ret = this.input.read(b, off, toRead);
",1,0
421,"-        final byte[] MOD_MAX = {1, -1, -1, -1, -1};
+        final byte[] MOD_MAX = {1, -1, -1, -1, 0x7f};
         final byte[] AC_ZERO = {2, 0, 0, 0, 0};
-        final byte[] AC_MAX = {2, -1, -1, -1, -1};
+        final byte[] AC_MAX = {2, -1, -1, -1, 0x7f};
         final byte[] CR_ZERO = {4, 0, 0, 0, 0};
-        final byte[] CR_MAX = {4, -1, -1, -1, -1};
+        final byte[] CR_MAX = {4, -1, -1, -1, 0x7f};
         final byte[] MOD_AC_ZERO = {3, 0, 0, 0, 0, 0, 0, 0, 0};
-        final byte[] MOD_AC_MAX = {3, -1, -1, -1, -1, -1, -1, -1, -1};
+        final byte[] MOD_AC_MAX = {3, -1, -1, -1, 0x7f, -1, -1, -1, 0x7f};
         final byte[] MOD_AC_CR_ZERO = {7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-        final byte[] MOD_AC_CR_MAX = {7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
+        final byte[] MOD_AC_CR_MAX = {7, -1, -1, -1, 0x7f, -1, -1, -1, 0x7f, -1, -1, -1, 0x7f};
",0,0
422,"-                    toRead = csize - readBytesOfEntry;
+                    // if it is smaller than toRead then it fits into an int
+                    toRead = (int) (csize - readBytesOfEntry);
",1,1
423,"-     *             if the compressor name is not known
+     *             if the compressor name is not known or not available
",0,0
424,"+     * @deprecated use #getLongGroupId instead as group ids can be
+     * bigger than {@link Integer.MAX_INT}
      */
+    @Deprecated
     public int getGroupId() {
-        return groupId;
+        return (int) (groupId & 0xffffffff);
",1,1
425,"-            setupRandPartA();
+            return setupRandPartA();
",0,1
426,"-                                                           en.limit()));
+                                                           en.limit()
+                                                           - en.position()));
",0,0
427,"+import java.util.Date;
",1,1
428,"-    private int currentChar = -1;
-
",1,0
429,"+    private int versionNeededToExtractMethod(int zipMethod) {
+        return zipMethod == DEFLATED ? DEFLATE_MIN_VERSION : INITIAL_VERSION;
+    }
",1,1
430,"+    workerInfo.setInetSocketAddress(server.getMyAddress());
 
-    NettyClient client = new NettyClient(context, conf);
-    client.connectAllAddresses(
-        Lists.<WorkerInfo>newArrayList(
-            new WorkerInfo(server.getMyAddress(), -1)));
+    NettyClient client = new NettyClient(context, conf, new WorkerInfo());
+    client.connectAllAddresses(Lists.<WorkerInfo>newArrayList(workerInfo));
",0,0
431,"-    classes.setVertexClass(PageRankVertex.class);
+    classes.setVertexClass(WeightedPageRankVertex.class);
",0,0
432,"-    if (edges != null) {
-      // If the iterable is actually a collection, we can cheaply get the
-      // size and initialize the hash-map with the expected capacity.
-      if (edges instanceof Collection) {
-        initialize(((Collection<Edge<I, E>>) edges).size());
-      } else {
-        initialize();
-      }
-      for (Edge<I, E> edge : edges) {
-        add(edge);
-      }
+    // If the iterable is actually a collection, we can cheaply get the
+    // size and initialize the hash-map with the expected capacity.
+    if (edges instanceof Collection) {
+      initialize(((Collection<Edge<I, E>>) edges).size());
+    } else {
+      initialize();
+    }
+    for (Edge<I, E> edge : edges) {
+      add(edge);
",1,0
433,"+  @Override
+  public <A extends Writable> void aggregate(String name, A value) {
+    AggregatorWrapper<? extends Writable> aggregator = getAggregator(name);
+    if (aggregator != null) {
+      ((AggregatorWrapper<A>) aggregator).aggregateCurrent(value);
+    } else {
+      throw new IllegalStateException(""aggregate: Tried to aggregate value "" +
+          ""to unregistered aggregator "" + name);
+    }
+  }
+
   /**
-   *  Marshal the aggregator values of to a JSONArray that will later be
-   *  aggregated by master.  Reset the 'use' of aggregators in the next
-   *  superstep
+   *  Marshal the aggregator values of the worker to a byte array that will
+   *  later be aggregated by master.
",1,0
434,"+        checkRequestsAfterChannelFailure(future);
",1,0
435,"-   * Get per-job metrics.
+   * Get per-job optional metrics.
+   *
+   * @return per-job optional {@link GiraphMetricsRegistry}
+   */
+  public GiraphMetricsRegistry perJobOptional() {
+    return perJobOptional;
+  }
+
+  /**
+   * Get per-job required metrics.
    *
-   * @return per-job GiraphMetricsRegistry
+   * @return per-job require {@link GiraphMetricsRegistry}
    */
-  public GiraphMetricsRegistry perJob() {
-    return perJob;
+  public GiraphMetricsRegistry perJobRequired() {
+    return perJobRequired;
",1,0
436,"-  /** Verify that the output format's generic params match the job. */
+  /** Verify that the vertex output format's generic params match the job. */
   private void verifyVertexOutputFormatGenericTypes() {
+    Class<? extends EdgeOutputFormat<I, V, E>>
+      edgeOutputFormatClass = conf.getEdgeOutputFormatClass();
+    if (conf.hasEdgeOutputFormat()) {
+      Class<?>[] classList =
+        getTypeArguments(EdgeOutputFormat.class, edgeOutputFormatClass);
+      checkAssignable(classList, ID_PARAM_INDEX, vertexIndexType(),
+          VertexOutputFormat.class, ""vertex index"");
+      checkAssignable(classList, VALUE_PARAM_INDEX, vertexValueType(),
+          VertexOutputFormat.class, ""vertex value"");
+      checkAssignable(classList, EDGE_PARAM_INDEX, edgeValueType(),
+          VertexOutputFormat.class, ""edge value"");
+    }
+  }
+
+  /** Verify that the edge output format's generic params match the job. */
+  private void verifyEdgeOutputFormatGenericTypes() {
",1,0
437,"+	      <exclude>SecureRPCCommunications.java</exclude>
",1,0
438,"-      registerAggregator(AGG_SUPERSTEP_TOTAL_BYTES,
-          LongSumAggregator.class);
-      registerAggregator(AGG_SUPERSTEP_TOTAL_MESSAGES,
-          LongSumAggregator.class);
-      registerAggregator(AGG_SUPERSTEP_TOTAL_MILLIS,
-          LongSumAggregator.class);
-      registerAggregator(WORKERS,
-          LongSumAggregator.class);
",1,0
439,"+    this.myTaskInfo = myTaskInfo;
",1,0
440,"+  GIRAPH-805: getZookeeperList can return null (armax00 via claudio)
+
",0,0
441,"-  
+ 
",0,0
442,"-      WorkerProgress.writeToZnode(getZkExt(), myProgressPath);
",1,0
